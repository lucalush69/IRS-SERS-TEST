[{"C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\index.js":"1","C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\App.js":"2","C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CandyMachine\\index.js":"3","C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CandyMachine\\helpers.js":"4","C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CountdownTimer\\index.js":"5","C:\\coding\\IRS SERS TEST\\app\\src\\index.js":"6","C:\\coding\\IRS SERS TEST\\app\\src\\App.js":"7","C:\\coding\\IRS SERS TEST\\app\\src\\CandyMachine\\index.js":"8","C:\\coding\\IRS SERS TEST\\app\\src\\CandyMachine\\helpers.js":"9","C:\\coding\\IRS SERS TEST\\app\\src\\CountdownTimer\\index.js":"10"},{"size":230,"mtime":1639112637767,"results":"11","hashOfConfig":"12"},{"size":2774,"mtime":1639363277929,"results":"13","hashOfConfig":"12"},{"size":12122,"mtime":1639455676935,"results":"14","hashOfConfig":"12"},{"size":529,"mtime":1639112637763,"results":"15","hashOfConfig":"12"},{"size":1675,"mtime":1639455426479,"results":"16","hashOfConfig":"12"},{"size":230,"mtime":1639112637767,"results":"17","hashOfConfig":"18"},{"size":2822,"mtime":1640048777210,"results":"19","hashOfConfig":"18"},{"size":12122,"mtime":1639455676935,"results":"20","hashOfConfig":"18"},{"size":529,"mtime":1639112637763,"results":"21","hashOfConfig":"18"},{"size":1675,"mtime":1639455426479,"results":"22","hashOfConfig":"18"},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"p4a3n0",{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34"},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1m186n2",{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\index.js",[],"C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\App.js",[],"C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CandyMachine\\index.js",["45"],"import { Connection, PublicKey } from '@solana/web3.js';\r\nimport { Program, Provider, web3 } from '@project-serum/anchor';\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\r\nimport { programs } from '@metaplex/js';\r\nimport './CandyMachine.css';\r\nimport CountdownTimer from '../CountdownTimer';\r\nimport React, { useEffect, useState } from 'react';\r\nimport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n} from './helpers';\r\nconst {\r\n  metadata: { Metadata, MetadataProgram },\r\n} = programs;\r\n\r\nconst config = new web3.PublicKey(process.env.REACT_APP_CANDY_MACHINE_CONFIG);\r\nconst { SystemProgram } = web3;\r\nconst opts = {\r\n  preflightCommitment: 'processed',\r\n};\r\n\r\nconst MAX_NAME_LENGTH = 32;\r\nconst MAX_URI_LENGTH = 200;\r\nconst MAX_SYMBOL_LENGTH = 10;\r\nconst MAX_CREATOR_LEN = 32 + 1 + 1;\r\n\r\nconst CandyMachine = ({ walletAddress }) => {\r\n  const [machineStats, setMachineStats] = useState(null);\r\n  // New state property\r\n  const [mints, setMints] = useState([]);\r\n  // Add these two state properties\r\n  const [isMinting, setIsMinting] = useState(false);\r\n  const [isLoadingMints, setIsLoadingMints] = useState(false);\r\n  \r\n\r\n  // Actions\r\n  const fetchHashTable = async (hash, metadataEnabled) => {\r\n    const connection = new web3.Connection(\r\n      process.env.REACT_APP_SOLANA_RPC_HOST\r\n    );\r\n\r\n    const metadataAccounts = await MetadataProgram.getProgramAccounts(\r\n      connection,\r\n      {\r\n        filters: [\r\n          {\r\n            memcmp: {\r\n              offset:\r\n                1 +\r\n                32 +\r\n                32 +\r\n                4 +\r\n                MAX_NAME_LENGTH +\r\n                4 +\r\n                MAX_URI_LENGTH +\r\n                4 +\r\n                MAX_SYMBOL_LENGTH +\r\n                2 +\r\n                1 +\r\n                4 +\r\n                0 * MAX_CREATOR_LEN,\r\n              bytes: hash,\r\n            },\r\n          },\r\n        ],\r\n      }\r\n    );\r\n\r\n    const mintHashes = [];\r\n\r\n    for (let index = 0; index < metadataAccounts.length; index++) {\r\n      const account = metadataAccounts[index];\r\n      const accountInfo = await connection.getParsedAccountInfo(account.pubkey);\r\n      const metadata = new Metadata(hash.toString(), accountInfo.value);\r\n      if (metadataEnabled) mintHashes.push(metadata.data);\r\n      else mintHashes.push(metadata.data.mint);\r\n    }\r\n\r\n    return mintHashes;\r\n    \r\n  };\r\n\r\n  const getMetadata = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getMasterEdition = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n          Buffer.from('edition'),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getTokenWallet = async (wallet, mint) => {\r\n    return (\r\n      await web3.PublicKey.findProgramAddress(\r\n        [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const mintToken = async () => {\r\n    try {\r\n      setIsMinting(true);\r\n      const mint = web3.Keypair.generate();\r\n      const token = await getTokenWallet(\r\n        walletAddress.publicKey,\r\n        mint.publicKey\r\n      );\r\n      const metadata = await getMetadata(mint.publicKey);\r\n      const masterEdition = await getMasterEdition(mint.publicKey);\r\n      const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n      const connection = new Connection(rpcHost);\r\n      const rent = await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span\r\n      );\r\n\r\n      const accounts = {\r\n        config,\r\n        candyMachine: process.env.REACT_APP_CANDY_MACHINE_ID,\r\n        payer: walletAddress.publicKey,\r\n        wallet: process.env.REACT_APP_TREASURY_ADDRESS,\r\n        mint: mint.publicKey,\r\n        metadata,\r\n        masterEdition,\r\n        mintAuthority: walletAddress.publicKey,\r\n        updateAuthority: walletAddress.publicKey,\r\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n        tokenProgram: TOKEN_PROGRAM_ID,\r\n        systemProgram: SystemProgram.programId,\r\n        rent: web3.SYSVAR_RENT_PUBKEY,\r\n        clock: web3.SYSVAR_CLOCK_PUBKEY,\r\n      };\r\n\r\n      const signers = [mint];\r\n      const instructions = [\r\n        web3.SystemProgram.createAccount({\r\n          fromPubkey: walletAddress.publicKey,\r\n          newAccountPubkey: mint.publicKey,\r\n          space: MintLayout.span,\r\n          lamports: rent,\r\n          programId: TOKEN_PROGRAM_ID,\r\n        }),\r\n        Token.createInitMintInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          0,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey\r\n        ),\r\n        createAssociatedTokenAccountInstruction(\r\n          token,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey,\r\n          mint.publicKey\r\n        ),\r\n        Token.createMintToInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          token,\r\n          walletAddress.publicKey,\r\n          [],\r\n          1\r\n        ),\r\n      ];\r\n\r\n      const provider = getProvider();\r\n      const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n      const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n      const txn = await program.rpc.mintNft({\r\n        accounts,\r\n        signers,\r\n        instructions,\r\n      });\r\n\r\n      console.log('txn:', txn);\r\n\r\n      // Setup listener\r\n      connection.onSignatureWithOptions(\r\n        txn,\r\n        async (notification, context) => {\r\n          if (notification.type === 'status') {\r\n            console.log('Receievd status event');\r\n\r\n            const { result } = notification;\r\n            if (!result.err) {\r\n              console.log('NFT Minted!');\r\n              //set our flag to fasle as aour NFT has been minted! \r\n              setIsMinting(false);\r\n              await getCandyMachineState();\r\n            }\r\n          }\r\n        },\r\n        { commitment: 'processed' }\r\n      );\r\n    } catch (error) {\r\n      let message = error.msg || 'Minting failed! Please try again!';\r\n\r\n      //if an error, set loading flag to false\r\n      setIsMinting(false);\r\n\r\n      if (!error.msg) {\r\n        if (error.message.indexOf('0x138')) {\r\n        } else if (error.message.indexOf('0x137')) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.message.indexOf('0x135')) {\r\n          message = `Insufficient funds to mint. Please fund your wallet.`;\r\n        }\r\n      } else {\r\n        if (error.code === 311) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.code === 312) {\r\n          message = `Minting period hasn't started yet.`;\r\n        }\r\n      }\r\n\r\n      console.warn(message);\r\n    }\r\n  };\r\n\r\n  const createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress,\r\n    payer,\r\n    walletAddress,\r\n    splTokenMintAddress\r\n  ) => {\r\n    const keys = [\r\n      { pubkey: payer, isSigner: true, isWritable: true },\r\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SystemProgram.programId,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n    ];\r\n    return new web3.TransactionInstruction({\r\n      keys,\r\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n      data: Buffer.from([]),\r\n    });\r\n  };\r\n\r\n\r\n\r\n  const getProvider = () => {\r\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n    // Create a new connection object\r\n    const connection = new Connection(rpcHost);\r\n    \r\n    // Create a new Solana provider object\r\n    const provider = new Provider(\r\n      connection,\r\n      window.solana,\r\n      opts.preflightCommitment\r\n    );\r\n    \r\n  return provider;\r\n};\r\n    \r\n  \r\n  // Declare getCandyMachineState as an async method\r\nconst getCandyMachineState = async () => { \r\n  const provider = getProvider();\r\n  \r\n  // Get metadata about your deployed candy machine program\r\n  const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n\r\n  // Create a program that you can call\r\n  const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n  // Fetch the metadata from your candy machine\r\n  const candyMachine = await program.account.candyMachine.fetch(\r\n    process.env.REACT_APP_CANDY_MACHINE_ID\r\n  );\r\n  \r\n  // Parse out all our metadata and log it out\r\n  const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\r\n  const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\r\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n  const goLiveData = candyMachine.data.goLiveDate.toNumber();\r\n\r\n  // We will be using this later in our UI so let's generate this now\r\nconst goLiveDateTimeString = `${new Date(\r\n  goLiveData * 1000\r\n).toLocaleDateString()} @ ${new Date(\r\n  goLiveData * 1000\r\n).toLocaleTimeString()}`;\r\n\r\n    // Add this data to your state to render\r\n  setMachineStats({\r\n      itemsAvailable,\r\n      itemsRedeemed,\r\n      itemsRemaining,\r\n      goLiveData,\r\n      goLiveDateTimeString,\r\n    });\r\n\r\n  console.log({\r\n    itemsAvailable,\r\n    itemsRedeemed,\r\n    itemsRemaining,\r\n    goLiveData,\r\n    goLiveDateTimeString,\r\n  });\r\n\r\n  setIsLoadingMints(true);\r\n\r\n  const data = await fetchHashTable(\r\n    process.env.REACT_APP_CANDY_MACHINE_ID,\r\n    true\r\n  );\r\n  \r\n  if (data.length !== 0) {\r\n    for (const mint of data) {\r\n      // Get URI\r\n      const response = await fetch(mint.data.uri);\r\n      const parse = await response.json();\r\n      console.log(\"Past Minted NFT\", mint)\r\n  \r\n      // Get image URI\r\n      if (!mints.find((mint) => mint === parse.image)) {\r\n        setMints((prevState) => [...prevState, parse.image]);\r\n      }\r\n    }\r\n  }\r\nsetIsLoadingMints(false);\r\n};\r\n\r\n\r\n\r\n\r\n\r\nuseEffect(() => {\r\n  getCandyMachineState();\r\n}, []);\r\n\r\n\r\nconst renderMintedItems = () => (\r\n  <div className=\"gif-container\">\r\n    <p className=\"sub-text\">Minted Items ✨</p>\r\n    <div className=\"gif-grid\">\r\n      {mints.map((mint) => (\r\n        <div className=\"gif-item\" key={mint}>\r\n          <img src={mint} alt={`Minted NFT ${mint}`} />\r\n        </div>\r\n      ))}\r\n    </div>\r\n  </div>\r\n);\r\n\r\n\r\nconst renderDropTimer = () => {\r\n  // Get the current date and dropDate in a JavaScript Date object\r\n  const currentDate = new Date();\r\n  const dropDate = new Date(machineStats.goLiveData * 1000);\r\n\r\n  // If currentDate is before dropDate, render our Countdown component\r\n  if (currentDate < dropDate) {\r\n    console.log('Before drop date!');\r\n    // Don't forget to pass over your dropDate!\r\n    return <CountdownTimer dropDate={dropDate} />;\r\n  }\r\n\r\n  // Else let's just return the current drop date\r\n  return <p>{`Drop Date: ${machineStats.goLiveDateTimeString}`}</p>;\r\n};\r\n  \r\n\r\nreturn (\r\n  machineStats && (\r\n    <div className=\"machine-container\">\r\n      {renderDropTimer()}\r\n      <p>{`Items Minted: ${machineStats.itemsRedeemed} / ${machineStats.itemsAvailable}`}</p>\r\n        {/* Check to see if these properties are equal! */}\r\n        {machineStats.itemsRedeemed === machineStats.itemsAvailable ? (\r\n          <p className=\"sub-text\">SOLD OUT BAYBEE</p>\r\n        ) : (\r\n          <button\r\n            className=\"cta-button mint-button\"\r\n            onClick={mintToken}\r\n            disabled={isMinting}\r\n          >\r\n            Mint NFT\r\n          </button>\r\n        )}\r\n      {mints.length > 0 && renderMintedItems()}\r\n      {isLoadingMints && <p>LOADING MINTS...</p>}\r\n    </div>\r\n  )\r\n);\r\n};\r\n\r\nexport default CandyMachine;\r\n","C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CandyMachine\\helpers.js",[],"C:\\coding\\BuildSpaceNFTSOL\\root\\solana_test_ok\\app\\src\\CountdownTimer\\index.js",["46"],"import React, { useEffect, useState } from 'react';\r\nimport './CountdownTimer.css';\r\n\r\nconst CountdownTimer = ({ dropDate }) => {\r\n  // State\r\n  const [timerString, setTimerString] = useState('');\r\n\r\n  // Our useEffect will run on component load\r\nuseEffect(() => {\r\n    console.log('Setting interval...');\r\n  \r\n    // Use setInterval to run this piece of code every second\r\n    const interval = setInterval(() => {\r\n      const currentDate = new Date().getTime();\r\n      const distance = dropDate - currentDate;\r\n  \r\n      // Here it's as easy as doing some time math to get the different properties\r\n      const days = Math.floor(distance / (1000 * 60 * 60 * 24));\r\n      const hours = Math.floor(\r\n        (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\r\n      );\r\n      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\r\n      const seconds = Math.floor((distance % (1000 * 60)) / 1000);\r\n  \r\n      // We have our desired output, set it in state!\r\n      setTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\r\n  \r\n      // If our distance passes zero this means that it's drop time!\r\n      if (distance < 0) {\r\n        console.log('Clearing interval...');\r\n        clearInterval(interval);\r\n      }\r\n    }, 1000);\r\n  \r\n    // Anytime our component unmounts let's clean up our interval\r\n    return () => {\r\n      if (interval) {\r\n        clearInterval(interval);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"timer-container\">\r\n      <p className=\"timer-header\">PROJECT DROPPING IN </p>\r\n      {timerString && <p className=\"timer-value\">{`⏰ ${timerString}`}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CountdownTimer;","C:\\coding\\IRS SERS TEST\\app\\src\\index.js",[],"C:\\coding\\IRS SERS TEST\\app\\src\\App.js",[],"C:\\coding\\IRS SERS TEST\\app\\src\\CandyMachine\\index.js",["47"],"C:\\coding\\IRS SERS TEST\\app\\src\\CandyMachine\\helpers.js",[],"C:\\coding\\IRS SERS TEST\\app\\src\\CountdownTimer\\index.js",["48"],{"ruleId":"49","severity":1,"message":"50","line":362,"column":4,"nodeType":"51","endLine":362,"endColumn":6,"suggestions":"52"},{"ruleId":"49","severity":1,"message":"53","line":41,"column":6,"nodeType":"51","endLine":41,"endColumn":8,"suggestions":"54"},{"ruleId":"49","severity":1,"message":"50","line":362,"column":4,"nodeType":"51","endLine":362,"endColumn":6,"suggestions":"55"},{"ruleId":"49","severity":1,"message":"53","line":41,"column":6,"nodeType":"51","endLine":41,"endColumn":8,"suggestions":"56"},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getCandyMachineState'. Either include it or remove the dependency array.","ArrayExpression",["57"],"React Hook useEffect has a missing dependency: 'dropDate'. Either include it or remove the dependency array.",["58"],["59"],["60"],{"desc":"61","fix":"62"},{"desc":"63","fix":"64"},{"desc":"61","fix":"65"},{"desc":"63","fix":"66"},"Update the dependencies array to be: [getCandyMachineState]",{"range":"67","text":"68"},"Update the dependencies array to be: [dropDate]",{"range":"69","text":"70"},{"range":"71","text":"68"},{"range":"72","text":"70"},[10429,10431],"[getCandyMachineState]",[1424,1426],"[dropDate]",[10429,10431],[1424,1426]]