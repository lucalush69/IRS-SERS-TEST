{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Program = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst accounts_1 = require(\"./accounts\");\n\nconst buffer_1 = require(\"buffer\");\n\nclass Program {\n  static findProgramAddress(seeds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield web3_js_1.PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];\n    });\n  }\n\n  static getProgramAccounts(connection, configOrCommitment) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const extra = {};\n      let commitment;\n\n      if (configOrCommitment) {\n        if (typeof configOrCommitment === 'string') {\n          commitment = configOrCommitment;\n        } else {\n          commitment = configOrCommitment.commitment;\n\n          if (configOrCommitment.dataSlice) {\n            extra.dataSlice = configOrCommitment.dataSlice;\n          }\n\n          if (configOrCommitment.filters) {\n            extra.filters = configOrCommitment.filters;\n          }\n        }\n      }\n\n      const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, 'base64', extra);\n\n      const unsafeRes = yield connection._rpcRequest('getProgramAccounts', args);\n      return unsafeRes.result.map(_ref => {\n        let {\n          account: {\n            data,\n            executable,\n            lamports,\n            owner\n          },\n          pubkey\n        } = _ref;\n        return {\n          account: {\n            data: buffer_1.Buffer.from(data[0], 'base64'),\n            executable,\n            lamports,\n            owner: new web3_js_1.PublicKey(owner)\n          },\n          pubkey: new web3_js_1.PublicKey(pubkey)\n        };\n      }).map(_ref2 => {\n        let {\n          pubkey,\n          account\n        } = _ref2;\n        return new accounts_1.Account(pubkey, account);\n      });\n    });\n  }\n\n}\n\nexports.Program = Program;","map":{"version":3,"sources":["../../src/Program.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAOA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAGA,MAAsB,OAAtB,CAA6B;AAGI,SAAlB,kBAAkB,CAAC,KAAD,EAA+B;;AAC5D,aAAO,CAAC,MAAM,SAAA,CAAA,SAAA,CAAU,kBAAV,CAA6B,KAA7B,EAAoC,KAAK,MAAzC,CAAP,EAAyD,CAAzD,CAAP;AACD,K;AAAA;;AAE8B,SAAlB,kBAAkB,CAC7B,UAD6B,EAE7B,kBAF6B,EAE6B;;AAE1D,YAAM,KAAK,GAA4D,EAAvE;AACA,UAAI,UAAJ;;AACA,UAAI,kBAAJ,EAAwB;AACtB,YAAI,OAAO,kBAAP,KAA8B,QAAlC,EAA4C;AAC1C,UAAA,UAAU,GAAG,kBAAb;AACD,SAFD,MAEO;AACL,UAAA,UAAU,GAAG,kBAAkB,CAAC,UAAhC;;AACA,cAAI,kBAAkB,CAAC,SAAvB,EAAkC;AAChC,YAAA,KAAK,CAAC,SAAN,GAAkB,kBAAkB,CAAC,SAArC;AACD;;AACD,cAAI,kBAAkB,CAAC,OAAvB,EAAgC;AAC9B,YAAA,KAAK,CAAC,OAAN,GAAgB,kBAAkB,CAAC,OAAnC;AACD;AACF;AACF;;AACD,YAAM,IAAI,GAAG,UAAU,CAAC,UAAX,CAAsB,CAAC,KAAK,MAAL,CAAY,QAAZ,EAAD,CAAtB,EAAgD,UAAhD,EAA4D,QAA5D,EAAsE,KAAtE,CAAb;;AACA,YAAM,SAAS,GAAG,MAAO,UAAwC,CAAC,WAAzC,CACvB,oBADuB,EAEvB,IAFuB,CAAzB;AAKA,aACE,SAAS,CAAC,MAAV,CAKC,GALD,CAKK;AAAA,YAAC;AAAE,UAAA,OAAO,EAAE;AAAE,YAAA,IAAF;AAAQ,YAAA,UAAR;AAAoB,YAAA,QAApB;AAA8B,YAAA;AAA9B,WAAX;AAAkD,UAAA;AAAlD,SAAD;AAAA,eAAiE;AACpE,UAAA,OAAO,EAAE;AACP,YAAA,IAAI,EAAE,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,IAAI,CAAC,CAAD,CAAhB,EAAqB,QAArB,CADC;AAEP,YAAA,UAFO;AAGP,YAAA,QAHO;AAIP,YAAA,KAAK,EAAE,IAAI,SAAA,CAAA,SAAJ,CAAc,KAAd;AAJA,WAD2D;AAOpE,UAAA,MAAM,EAAE,IAAI,SAAA,CAAA,SAAJ,CAAc,MAAd;AAP4D,SAAjE;AAAA,OALL,EAcC,GAdD,CAcK;AAAA,YAAC;AAAE,UAAA,MAAF;AAAU,UAAA;AAAV,SAAD;AAAA,eAAyB,IAAI,UAAA,CAAA,OAAJ,CAAY,MAAZ,EAAoB,OAApB,CAAzB;AAAA,OAdL,CADF;AAgBD,K;AAAA;;AAhD0B;;AAA7B,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Program = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst accounts_1 = require(\"./accounts\");\nconst buffer_1 = require(\"buffer\");\nclass Program {\n    static findProgramAddress(seeds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield web3_js_1.PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];\n        });\n    }\n    static getProgramAccounts(connection, configOrCommitment) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const extra = {};\n            let commitment;\n            if (configOrCommitment) {\n                if (typeof configOrCommitment === 'string') {\n                    commitment = configOrCommitment;\n                }\n                else {\n                    commitment = configOrCommitment.commitment;\n                    if (configOrCommitment.dataSlice) {\n                        extra.dataSlice = configOrCommitment.dataSlice;\n                    }\n                    if (configOrCommitment.filters) {\n                        extra.filters = configOrCommitment.filters;\n                    }\n                }\n            }\n            const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, 'base64', extra);\n            const unsafeRes = yield connection._rpcRequest('getProgramAccounts', args);\n            return unsafeRes.result\n                .map(({ account: { data, executable, lamports, owner }, pubkey }) => ({\n                account: {\n                    data: buffer_1.Buffer.from(data[0], 'base64'),\n                    executable,\n                    lamports,\n                    owner: new web3_js_1.PublicKey(owner),\n                },\n                pubkey: new web3_js_1.PublicKey(pubkey),\n            }))\n                .map(({ pubkey, account }) => new accounts_1.Account(pubkey, account));\n        });\n    }\n}\nexports.Program = Program;\n//# sourceMappingURL=Program.js.map"]},"metadata":{},"sourceType":"script"}