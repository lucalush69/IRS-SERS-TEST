{"ast":null,"code":"import axios from 'axios';\nimport { clusterApiUrl, Connection as Connection$1, PublicKey, SystemProgram, TransactionInstruction, SYSVAR_RENT_PUBKEY, Keypair, Transaction as Transaction$1 } from '@solana/web3.js';\nimport { sha256 } from 'crypto-hash';\nimport { Buffer as Buffer$1 } from 'buffer';\nimport { Transaction, config, Account } from '@metaplex-foundation/mpl-core';\nimport { Store, SetStore, StoreConfig, SetStoreV2, AuctionManager, MetaplexProgram, SafetyDepositConfig, RedeemFullRightsTransferBid, PrizeTrackingTicket, RedeemPrintingV2Bid, RedeemParticipationBidV3, WinningConstraint, NonWinningConstraint, ClaimBid, WinningConfigType } from '@metaplex-foundation/mpl-metaplex';\nimport BN from 'bn.js';\nimport { Metadata, MasterEdition, Creator, MetadataDataData, CreateMetadata, CreateMasterEdition, EditionMarker, Edition, MintNewEditionFromMasterEditionViaToken, SignMetadata, UpdateMetadata, UpdatePrimarySaleHappenedViaToken } from '@metaplex-foundation/mpl-token-metadata';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token, AccountLayout, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';\nimport { Vault, ActivateVault, CombineVault, VaultProgram, InitVault, ExternalPriceAccountData, UpdateExternalPriceAccount } from '@metaplex-foundation/mpl-token-vault';\nimport { AuctionExtended, BidderPot, BidderMetadata, CancelBid, PlaceBid, Auction } from '@metaplex-foundation/mpl-auction';\nvar Currency;\n\n(function (Currency) {\n  Currency[\"USD\"] = \"usd\";\n  Currency[\"EUR\"] = \"eur\";\n  Currency[\"AR\"] = \"ar\";\n  Currency[\"SOL\"] = \"sol\";\n})(Currency || (Currency = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nclass Coingecko {\n  static translateCurrency(currency) {\n    switch (currency) {\n      case Currency.AR:\n        return 'arweave';\n\n      case Currency.SOL:\n        return 'solana';\n\n      case Currency.USD:\n        return 'usd';\n\n      case Currency.EUR:\n        return 'eur';\n\n      default:\n        throw new Error('Invalid currency supplied to Coingecko conversion rate provider');\n    }\n  }\n\n  getRate(from, to) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fromArray = typeof from === 'string' ? [from] : from;\n      const toArray = typeof to === 'string' ? [to] : to;\n      const fromIds = fromArray.map(currency => Coingecko.translateCurrency(currency)).join(',');\n      const toIds = toArray.map(currency => Coingecko.translateCurrency(currency)).join(',');\n      const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromIds}&vs_currencies=${toIds}`;\n      const response = yield axios(url);\n      const data = yield response.data;\n      return fromArray.reduce((previousPairs, fromCurrency) => {\n        return [...previousPairs, ...toArray.map(toCurrency => ({\n          from: fromCurrency,\n          to: toCurrency,\n          rate: data[Coingecko.translateCurrency(fromCurrency)][Coingecko.translateCurrency(toCurrency)]\n        }))];\n      }, []);\n    });\n  }\n\n}\n/* eslint-env browser */\n\n\nvar browser = typeof self == 'object' ? self.FormData : window.FormData;\nconst ARWEAVE_URL = 'https://arweave.net';\nconst LAMPORT_MULTIPLIER = Math.pow(10, 9);\nconst WINSTON_MULTIPLIER = Math.pow(10, 12);\n\nclass ArweaveStorage {\n  constructor(_ref) {\n    let {\n      endpoint,\n      env\n    } = _ref;\n    this.endpoint = endpoint;\n    this.env = env;\n  }\n\n  getAssetCostToStore(files, arweaveRate, solanaRate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buffers = Array.from(files.values());\n      const totalBytes = buffers.reduce((sum, f) => sum += f.byteLength, 0);\n      const txnFeeInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/0`)).data);\n      const byteCostInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/${totalBytes.toString()}`)).data);\n      const totalArCost = (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;\n      const arMultiplier = arweaveRate / solanaRate;\n      return LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1;\n    });\n  }\n\n  upload(files, mintKey, txid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fileEntries = Array.from(files.entries());\n      const tags = fileEntries.reduce((acc, _ref2) => {\n        let [fileName] = _ref2;\n        acc[fileName] = [{\n          name: 'mint',\n          value: mintKey\n        }];\n        return acc;\n      }, {});\n      const body = new browser();\n      body.append('tags', JSON.stringify(tags));\n      body.append('transaction', txid);\n      body.append('env', this.env);\n      fileEntries.map(_ref3 => {\n        let [, file] = _ref3;\n        body.append('file[]', file);\n      });\n      const response = yield axios.post(this.endpoint, body);\n\n      if (response.data.error) {\n        return Promise.reject(new Error(response.data.error));\n      }\n\n      return response.data;\n    });\n  }\n\n}\n\nvar ChainId;\n\n(function (ChainId) {\n  ChainId[ChainId[\"MainnetBeta\"] = 101] = \"MainnetBeta\";\n  ChainId[ChainId[\"Testnet\"] = 102] = \"Testnet\";\n  ChainId[ChainId[\"Devnet\"] = 103] = \"Devnet\";\n})(ChainId || (ChainId = {}));\n\nconst ENV = {\n  devnet: {\n    endpoint: clusterApiUrl('devnet'),\n    ChainId: ChainId.Devnet\n  },\n  'mainnet-beta': {\n    endpoint: 'https://api.metaplex.solana.com/',\n    ChainId: ChainId.MainnetBeta\n  },\n  'mainnet-beta (Solana)': {\n    endpoint: 'https://api.mainnet-beta.solana.com',\n    ChainId: ChainId.MainnetBeta\n  },\n  'mainnet-beta (Serum)': {\n    endpoint: 'https://solana-api.projectserum.com/',\n    ChainId: ChainId.MainnetBeta\n  },\n  testnet: {\n    endpoint: clusterApiUrl('testnet'),\n    ChainId: ChainId.Testnet\n  }\n};\n\nclass Connection extends Connection$1 {\n  constructor() {\n    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'mainnet-beta';\n    let commitment = arguments.length > 1 ? arguments[1] : undefined;\n    if (endpoint in ENV) endpoint = ENV[endpoint].endpoint;\n    super(endpoint, commitment);\n  }\n\n}\n\nclass NodeWallet {\n  constructor(payer) {\n    this.payer = payer;\n  }\n\n  signTransaction(tx) {\n    return __awaiter(this, void 0, void 0, function* () {\n      tx.partialSign(this.payer);\n      return tx;\n    });\n  }\n\n  signAllTransactions(txs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return txs.map(tx => {\n        tx.partialSign(this.payer);\n        return tx;\n      });\n    });\n  }\n\n  get publicKey() {\n    return this.payer.publicKey;\n  }\n\n}\n\nconst getFileHash = file => __awaiter(void 0, void 0, void 0, function* () {\n  return Buffer$1.from(yield sha256(file.toString()));\n});\n\nvar crypto = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getFileHash: getFileHash\n});\n\nconst lookup = url => __awaiter(void 0, void 0, void 0, function* () {\n  try {\n    const {\n      data\n    } = yield axios.get(url);\n    return data;\n  } catch (_a) {\n    throw new Error(`unable to get metadata json from url ${url}`);\n  }\n});\n\nvar metadata = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lookup: lookup\n});\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Crypto: crypto,\n  metadata: metadata\n});\n\nconst sendTransaction = _ref4 => {\n  let {\n    connection,\n    wallet,\n    txs,\n    signers = [],\n    options\n  } = _ref4;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    let tx = Transaction.fromCombined(txs, {\n      feePayer: wallet.publicKey\n    });\n    tx.recentBlockhash = (yield connection.getRecentBlockhash()).blockhash;\n\n    if (signers.length) {\n      tx.partialSign(...signers);\n    }\n\n    tx = yield wallet.signTransaction(tx);\n    return connection.sendRawTransaction(tx.serialize(), options);\n  });\n};\n\nconst initStore = _ref5 => {\n  let {\n    connection,\n    wallet,\n    isPublic = true\n  } = _ref5;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const storeId = yield Store.getPDA(wallet.publicKey);\n    const tx = new SetStore({\n      feePayer: wallet.publicKey\n    }, {\n      admin: new PublicKey(wallet.publicKey),\n      store: storeId,\n      isPublic\n    });\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: [tx]\n    });\n    return {\n      storeId,\n      txId\n    };\n  });\n};\n\nconst initStoreV2 = _ref6 => {\n  let {\n    connection,\n    wallet,\n    settingsUri = null,\n    isPublic = true\n  } = _ref6;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const storeId = yield Store.getPDA(wallet.publicKey);\n    const configId = yield StoreConfig.getPDA(storeId);\n    const tx = new SetStoreV2({\n      feePayer: wallet.publicKey\n    }, {\n      admin: new PublicKey(wallet.publicKey),\n      store: storeId,\n      config: configId,\n      isPublic,\n      settingsUri\n    });\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: [tx]\n    });\n    return {\n      storeId,\n      configId,\n      txId\n    };\n  });\n};\n\nclass PayForFiles extends Transaction {\n  constructor(options, params) {\n    const {\n      feePayer\n    } = options;\n    const {\n      lamports,\n      fileHashes,\n      arweaveWallet\n    } = params;\n    super(options);\n    this.add(SystemProgram.transfer({\n      fromPubkey: feePayer,\n      toPubkey: arweaveWallet !== null && arweaveWallet !== void 0 ? arweaveWallet : new PublicKey(config.arweaveWallet),\n      lamports\n    }));\n    fileHashes.forEach(data => {\n      this.add(new TransactionInstruction({\n        keys: [],\n        programId: new PublicKey(config.programs.memo),\n        data\n      }));\n    });\n  }\n\n}\n\nclass CreateMint extends Transaction {\n  constructor(options, params) {\n    const {\n      feePayer\n    } = options;\n    const {\n      newAccountPubkey,\n      lamports,\n      decimals,\n      owner,\n      freezeAuthority\n    } = params;\n    super(options);\n    this.add(SystemProgram.createAccount({\n      fromPubkey: feePayer,\n      newAccountPubkey,\n      lamports,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n    this.add(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, newAccountPubkey, decimals !== null && decimals !== void 0 ? decimals : 0, owner !== null && owner !== void 0 ? owner : feePayer, freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : feePayer));\n  }\n\n}\n\nclass CreateTokenAccount extends Transaction {\n  constructor(options, params) {\n    const {\n      feePayer\n    } = options;\n    const {\n      newAccountPubkey,\n      lamports,\n      mint,\n      owner\n    } = params;\n    super(options);\n    this.add(SystemProgram.createAccount({\n      fromPubkey: feePayer,\n      newAccountPubkey,\n      lamports,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n    this.add(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner !== null && owner !== void 0 ? owner : feePayer));\n  }\n\n}\n\nclass CreateAssociatedTokenAccount extends Transaction {\n  constructor(options, params) {\n    const {\n      feePayer\n    } = options;\n    const {\n      associatedTokenAddress,\n      walletAddress,\n      splTokenMintAddress\n    } = params;\n    super(options);\n    this.add(new TransactionInstruction({\n      keys: [{\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: walletAddress !== null && walletAddress !== void 0 ? walletAddress : feePayer,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: splTokenMintAddress,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n      data: Buffer$1.from([])\n    }));\n  }\n\n}\n\nclass MintTo extends Transaction {\n  constructor(options, params) {\n    const {\n      feePayer\n    } = options;\n    const {\n      mint,\n      dest,\n      authority,\n      amount\n    } = params;\n    super(options);\n    this.add(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, dest, authority !== null && authority !== void 0 ? authority : feePayer, [], new BN(amount).toNumber()));\n  }\n\n}\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  PayForFiles: PayForFiles,\n  CreateMint: CreateMint,\n  CreateTokenAccount: CreateTokenAccount,\n  CreateAssociatedTokenAccount: CreateAssociatedTokenAccount,\n  MintTo: MintTo\n});\n\nfunction prepareTokenAccountAndMintTxs(connection, owner) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mint = Keypair.generate();\n    const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);\n    const createMintTx = new CreateMint({\n      feePayer: owner\n    }, {\n      newAccountPubkey: mint.publicKey,\n      lamports: mintRent\n    });\n    const recipient = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint.publicKey, owner);\n    const createAssociatedTokenAccountTx = new CreateAssociatedTokenAccount({\n      feePayer: owner\n    }, {\n      associatedTokenAddress: recipient,\n      splTokenMintAddress: mint.publicKey\n    });\n    const mintToTx = new MintTo({\n      feePayer: owner\n    }, {\n      mint: mint.publicKey,\n      dest: recipient,\n      amount: 1\n    });\n    return {\n      mint,\n      createMintTx,\n      createAssociatedTokenAccountTx,\n      mintToTx,\n      recipient\n    };\n  });\n}\n\nfunction createWrappedAccountTxs(connection, owner) {\n  let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return __awaiter(this, void 0, void 0, function* () {\n    const account = Keypair.generate();\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const createTokenAccountTx = new CreateTokenAccount({\n      feePayer: owner\n    }, {\n      newAccountPubkey: account.publicKey,\n      lamports: amount + accountRentExempt,\n      mint: NATIVE_MINT\n    });\n    const closeTokenAccountTx = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, owner, owner, []));\n    return {\n      account,\n      createTokenAccountTx,\n      closeTokenAccountTx\n    };\n  });\n}\n\nfunction createApproveTxs(args) {\n  const {\n    authority = Keypair.generate(),\n    account,\n    owner,\n    amount\n  } = args;\n  const createApproveTx = new Transaction$1().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account, authority.publicKey, owner, [], amount));\n  const createRevokeTx = new Transaction$1().add(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, account, owner, []));\n  return {\n    authority,\n    createApproveTx,\n    createRevokeTx\n  };\n}\n\nconst mintNFT = _ref7 => {\n  let {\n    connection,\n    wallet,\n    uri,\n    maxSupply\n  } = _ref7;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const {\n      mint,\n      createMintTx,\n      createAssociatedTokenAccountTx,\n      mintToTx\n    } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n    const metadataPDA = yield Metadata.getPDA(mint.publicKey);\n    const editionPDA = yield MasterEdition.getPDA(mint.publicKey);\n    const {\n      name,\n      symbol,\n      seller_fee_basis_points,\n      properties: {\n        creators\n      }\n    } = yield lookup(uri);\n    const creatorsData = creators.reduce((memo, _ref8) => {\n      let {\n        address,\n        share\n      } = _ref8;\n      const verified = address === wallet.publicKey.toString();\n      const creator = new Creator({\n        address,\n        share,\n        verified\n      });\n      memo = [...memo, creator];\n      return memo;\n    }, []);\n    const metadataData = new MetadataDataData({\n      name,\n      symbol,\n      uri,\n      sellerFeeBasisPoints: seller_fee_basis_points,\n      creators: creatorsData\n    });\n    const createMetadataTx = new CreateMetadata({\n      feePayer: wallet.publicKey\n    }, {\n      metadata: metadataPDA,\n      metadataData,\n      updateAuthority: wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey\n    });\n    const masterEditionTx = new CreateMasterEdition({\n      feePayer: wallet.publicKey\n    }, {\n      edition: editionPDA,\n      metadata: metadataPDA,\n      updateAuthority: wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey,\n      maxSupply: maxSupply ? new BN(maxSupply) : null\n    });\n    const txId = yield sendTransaction({\n      connection,\n      signers: [mint],\n      txs: [createMintTx, createMetadataTx, createAssociatedTokenAccountTx, mintToTx, masterEditionTx],\n      wallet\n    });\n    return {\n      txId,\n      mint: mint.publicKey,\n      metadata: metadataPDA,\n      edition: editionPDA\n    };\n  });\n};\n\nconst mintEditionFromMaster = function () {\n  let {\n    connection,\n    wallet,\n    masterEditionMint,\n    updateAuthority\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const masterPDA = yield MasterEdition.getPDA(masterEditionMint);\n    const masterMetaPDA = yield Metadata.getPDA(masterEditionMint);\n    const masterInfo = yield Account.getInfo(connection, masterPDA);\n    const masterData = new MasterEdition(masterPDA, masterInfo).data;\n    const editionValue = masterData.supply.add(new BN(1));\n    const {\n      mint,\n      createMintTx,\n      createAssociatedTokenAccountTx,\n      mintToTx\n    } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n    const tokenAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, masterEditionMint, wallet.publicKey);\n    const metadataPDA = yield Metadata.getPDA(mint.publicKey);\n    const editionMarker = yield EditionMarker.getPDA(masterEditionMint, editionValue);\n    const editionPDA = yield Edition.getPDA(mint.publicKey);\n    const newEditionFromMasterTx = new MintNewEditionFromMasterEditionViaToken({\n      feePayer: wallet.publicKey\n    }, {\n      edition: editionPDA,\n      metadata: metadataPDA,\n      updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey,\n      masterEdition: masterPDA,\n      masterMetadata: masterMetaPDA,\n      editionMarker,\n      tokenOwner: wallet.publicKey,\n      tokenAccount,\n      editionValue\n    });\n    const txId = yield sendTransaction({\n      connection,\n      signers: [mint],\n      txs: [createMintTx, createAssociatedTokenAccountTx, mintToTx, newEditionFromMasterTx],\n      wallet\n    });\n    return {\n      txId,\n      mint: mint.publicKey,\n      metadata: metadataPDA,\n      edition: editionPDA\n    };\n  });\n};\n\nclass TransactionsBatch {\n  constructor(_ref9) {\n    let {\n      beforeTransactions = [],\n      transactions,\n      afterTransactions = []\n    } = _ref9;\n    this.signers = [];\n    this.beforeTransactions = beforeTransactions;\n    this.transactions = transactions;\n    this.afterTransactions = afterTransactions;\n  }\n\n  addSigner(signer) {\n    this.signers.push(signer);\n  }\n\n  addBeforeTransaction(transaction) {\n    this.beforeTransactions.push(transaction);\n  }\n\n  addTransaction(transaction) {\n    this.transactions.push(transaction);\n  }\n\n  addAfterTransaction(transaction) {\n    this.afterTransactions.push(transaction);\n  }\n\n  toTransactions() {\n    return [...this.beforeTransactions, ...this.transactions, ...this.afterTransactions];\n  }\n\n  toInstructions() {\n    return this.toTransactions().flatMap(t => t.instructions);\n  }\n\n}\n\nconst closeVault = _ref10 => {\n  let {\n    connection,\n    wallet,\n    vault,\n    priceMint\n  } = _ref10;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const fractionMintAuthority = yield Vault.getPDA(vault);\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const txOptions = {\n      feePayer: wallet.publicKey\n    };\n    const {\n      data: {\n        fractionMint,\n        fractionTreasury,\n        redeemTreasury,\n        pricingLookupAddress\n      }\n    } = yield Vault.load(connection, vault);\n    const fractionMintKey = new PublicKey(fractionMint);\n    const fractionTreasuryKey = new PublicKey(fractionTreasury);\n    const redeemTreasuryKey = new PublicKey(redeemTreasury);\n    const pricingLookupAddressKey = new PublicKey(pricingLookupAddress);\n    const activateVaultTx = new ActivateVault(txOptions, {\n      vault,\n      numberOfShares: new BN(0),\n      fractionMint: fractionMintKey,\n      fractionTreasury: fractionTreasuryKey,\n      fractionMintAuthority,\n      vaultAuthority: wallet.publicKey\n    });\n    txBatch.addTransaction(activateVaultTx);\n    const outstandingShareAccount = Keypair.generate();\n    const outstandingShareAccountTx = new CreateTokenAccount(txOptions, {\n      newAccountPubkey: outstandingShareAccount.publicKey,\n      lamports: accountRent,\n      mint: fractionMintKey,\n      owner: wallet.publicKey\n    });\n    txBatch.addTransaction(outstandingShareAccountTx);\n    txBatch.addSigner(outstandingShareAccount);\n    const payingTokenAccount = Keypair.generate();\n    const payingTokenAccountTx = new CreateTokenAccount(txOptions, {\n      newAccountPubkey: payingTokenAccount.publicKey,\n      lamports: accountRent,\n      mint: priceMint,\n      owner: wallet.publicKey\n    });\n    txBatch.addTransaction(payingTokenAccountTx);\n    txBatch.addSigner(payingTokenAccount);\n    const transferAuthority = Keypair.generate();\n\n    const createApproveTx = account => new Transaction().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account.publicKey, transferAuthority.publicKey, wallet.publicKey, [], 0));\n\n    txBatch.addTransaction(createApproveTx(payingTokenAccount));\n    txBatch.addTransaction(createApproveTx(outstandingShareAccount));\n    txBatch.addSigner(transferAuthority);\n    const combineVaultTx = new CombineVault(txOptions, {\n      vault,\n      outstandingShareTokenAccount: outstandingShareAccount.publicKey,\n      payingTokenAccount: payingTokenAccount.publicKey,\n      fractionMint: fractionMintKey,\n      fractionTreasury: fractionTreasuryKey,\n      redeemTreasury: redeemTreasuryKey,\n      burnAuthority: fractionMintAuthority,\n      externalPriceAccount: pricingLookupAddressKey,\n      transferAuthority: transferAuthority.publicKey,\n      vaultAuthority: wallet.publicKey,\n      newVaultAuthority: wallet.publicKey\n    });\n    txBatch.addTransaction(combineVaultTx);\n    const txId = yield sendTransaction({\n      connection,\n      signers: txBatch.signers,\n      txs: txBatch.transactions,\n      wallet\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst createVault = _ref11 => {\n  let {\n    connection,\n    wallet,\n    priceMint = NATIVE_MINT,\n    externalPriceAccount\n  } = _ref11;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);\n    const vaultRent = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_VAULT_SIZE);\n    const vault = Keypair.generate();\n    const vaultAuthority = yield Vault.getPDA(vault.publicKey);\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const fractionMint = Keypair.generate();\n    const fractionMintTx = new CreateMint({\n      feePayer: wallet.publicKey\n    }, {\n      newAccountPubkey: fractionMint.publicKey,\n      lamports: mintRent,\n      owner: vaultAuthority,\n      freezeAuthority: vaultAuthority\n    });\n    txBatch.addTransaction(fractionMintTx);\n    txBatch.addSigner(fractionMint);\n    const redeemTreasury = Keypair.generate();\n    const redeemTreasuryTx = new CreateTokenAccount({\n      feePayer: wallet.publicKey\n    }, {\n      newAccountPubkey: redeemTreasury.publicKey,\n      lamports: accountRent,\n      mint: priceMint,\n      owner: vaultAuthority\n    });\n    txBatch.addTransaction(redeemTreasuryTx);\n    txBatch.addSigner(redeemTreasury);\n    const fractionTreasury = Keypair.generate();\n    const fractionTreasuryTx = new CreateTokenAccount({\n      feePayer: wallet.publicKey\n    }, {\n      newAccountPubkey: fractionTreasury.publicKey,\n      lamports: accountRent,\n      mint: fractionMint.publicKey,\n      owner: vaultAuthority\n    });\n    txBatch.addTransaction(fractionTreasuryTx);\n    txBatch.addSigner(fractionTreasury);\n    const uninitializedVaultTx = new Transaction().add(SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: vault.publicKey,\n      lamports: vaultRent,\n      space: Vault.MAX_VAULT_SIZE,\n      programId: VaultProgram.PUBKEY\n    }));\n    txBatch.addTransaction(uninitializedVaultTx);\n    txBatch.addSigner(vault);\n    const initVaultTx = new InitVault({\n      feePayer: wallet.publicKey\n    }, {\n      vault: vault.publicKey,\n      vaultAuthority: wallet.publicKey,\n      fractionalTreasury: fractionTreasury.publicKey,\n      pricingLookupAddress: externalPriceAccount,\n      redeemTreasury: redeemTreasury.publicKey,\n      fractionalMint: fractionMint.publicKey,\n      allowFurtherShareCreation: true\n    });\n    txBatch.addTransaction(initVaultTx);\n    const txId = yield sendTransaction({\n      connection,\n      signers: txBatch.signers,\n      txs: txBatch.transactions,\n      wallet\n    });\n    return {\n      txId,\n      vault: vault.publicKey,\n      fractionMint: fractionMint.publicKey,\n      redeemTreasury: redeemTreasury.publicKey,\n      fractionTreasury: fractionTreasury.publicKey\n    };\n  });\n};\n\nconst createExternalPriceAccount = _ref12 => {\n  let {\n    connection,\n    wallet\n  } = _ref12;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const txOptions = {\n      feePayer: wallet.publicKey\n    };\n    const epaRentExempt = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_EXTERNAL_ACCOUNT_SIZE);\n    const externalPriceAccount = Keypair.generate();\n    const externalPriceAccountData = new ExternalPriceAccountData({\n      pricePerShare: new BN(0),\n      priceMint: NATIVE_MINT.toBase58(),\n      allowedToCombine: true\n    });\n    const uninitializedEPA = new Transaction().add(SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: externalPriceAccount.publicKey,\n      lamports: epaRentExempt,\n      space: Vault.MAX_EXTERNAL_ACCOUNT_SIZE,\n      programId: VaultProgram.PUBKEY\n    }));\n    txBatch.addTransaction(uninitializedEPA);\n    txBatch.addSigner(externalPriceAccount);\n    const updateEPA = new UpdateExternalPriceAccount(txOptions, {\n      externalPriceAccount: externalPriceAccount.publicKey,\n      externalPriceAccountData\n    });\n    txBatch.addTransaction(updateEPA);\n    const txId = yield sendTransaction({\n      connection,\n      signers: txBatch.signers,\n      txs: txBatch.transactions,\n      wallet\n    });\n    return {\n      txId,\n      externalPriceAccount: externalPriceAccount.publicKey,\n      priceMint: NATIVE_MINT\n    };\n  });\n};\n\nconst createMetadata = function () {\n  let {\n    connection,\n    wallet,\n    editionMint,\n    metadataData,\n    updateAuthority\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield Metadata.getPDA(editionMint);\n    const createMetadataTx = new CreateMetadata({\n      feePayer: wallet.publicKey\n    }, {\n      metadata,\n      metadataData,\n      updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n      mint: editionMint,\n      mintAuthority: wallet.publicKey\n    });\n    return sendTransaction({\n      connection,\n      signers: [],\n      txs: [createMetadataTx],\n      wallet\n    });\n  });\n};\n\nconst createMasterEdition = function () {\n  let {\n    connection,\n    wallet,\n    editionMint,\n    updateAuthority,\n    maxSupply\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield Metadata.getPDA(editionMint);\n    const edition = yield MasterEdition.getPDA(editionMint);\n    const createMetadataTx = new CreateMasterEdition({\n      feePayer: wallet.publicKey\n    }, {\n      edition,\n      metadata,\n      updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n      mint: editionMint,\n      mintAuthority: wallet.publicKey,\n      maxSupply\n    });\n    return sendTransaction({\n      connection,\n      signers: [],\n      txs: [createMetadataTx],\n      wallet\n    });\n  });\n};\n\nconst signMetadata = function () {\n  let {\n    connection,\n    wallet,\n    editionMint,\n    signer\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield Metadata.getPDA(editionMint);\n    const signTx = new SignMetadata({\n      feePayer: wallet.publicKey\n    }, {\n      metadata,\n      creator: signer ? signer.publicKey : wallet.publicKey\n    });\n    return yield sendTransaction({\n      connection,\n      signers: signer ? [signer] : [],\n      txs: [signTx],\n      wallet\n    });\n  });\n};\n\nconst updateMetadata = function () {\n  let {\n    connection,\n    wallet,\n    editionMint,\n    newMetadataData,\n    newUpdateAuthority,\n    primarySaleHappened\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield Metadata.getPDA(editionMint);\n    const updateTx = new UpdateMetadata({\n      feePayer: wallet.publicKey\n    }, {\n      metadata,\n      updateAuthority: wallet.publicKey,\n      metadataData: newMetadataData,\n      newUpdateAuthority,\n      primarySaleHappened\n    });\n    return sendTransaction({\n      connection,\n      signers: [],\n      txs: [updateTx],\n      wallet\n    });\n  });\n};\n\nconst cancelBid = _ref13 => {\n  let {\n    connection,\n    wallet,\n    auction,\n    bidderPotToken,\n    destAccount\n  } = _ref13;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const bidder = wallet.publicKey;\n    const auctionManager = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManager);\n    const {\n      data: {\n        tokenMint\n      }\n    } = yield manager.getAuction(connection);\n    const auctionTokenMint = new PublicKey(tokenMint);\n    const vault = new PublicKey(manager.data.vault);\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const txBatch = yield getCancelBidTransactions({\n      destAccount,\n      bidder,\n      accountRentExempt,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      auctionTokenMint,\n      vault\n    });\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txBatch.toTransactions(),\n      signers: txBatch.signers\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst getCancelBidTransactions = _ref14 => {\n  let {\n    destAccount,\n    bidder,\n    accountRentExempt,\n    bidderPot,\n    bidderPotToken,\n    bidderMeta,\n    auction,\n    auctionExtended,\n    auctionTokenMint,\n    vault\n  } = _ref14;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n\n    if (!destAccount) {\n      const account = Keypair.generate();\n      const createTokenAccountTransaction = new CreateTokenAccount({\n        feePayer: bidder\n      }, {\n        newAccountPubkey: account.publicKey,\n        lamports: accountRentExempt,\n        mint: NATIVE_MINT\n      });\n      const closeTokenAccountInstruction = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, bidder, bidder, []));\n      txBatch.addTransaction(createTokenAccountTransaction);\n      txBatch.addAfterTransaction(closeTokenAccountInstruction);\n      txBatch.addSigner(account);\n      destAccount = account.publicKey;\n    }\n\n    const cancelBidTransaction = new CancelBid({\n      feePayer: bidder\n    }, {\n      bidder,\n      bidderToken: destAccount,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      tokenMint: auctionTokenMint,\n      resource: vault\n    });\n    txBatch.addTransaction(cancelBidTransaction);\n    return txBatch;\n  });\n};\n\nconst placeBid = _ref15 => {\n  let {\n    connection,\n    wallet,\n    amount,\n    auction,\n    bidderPotToken\n  } = _ref15;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const bidder = wallet.publicKey;\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const auctionManager = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManager);\n    const {\n      data: {\n        tokenMint\n      }\n    } = yield manager.getAuction(connection);\n    const auctionTokenMint = new PublicKey(tokenMint);\n    const vault = new PublicKey(manager.data.vault);\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\n    let txBatch = new TransactionsBatch({\n      transactions: []\n    });\n\n    if (bidderPotToken) {\n      txBatch = yield getCancelBidTransactions({\n        destAccount: null,\n        bidder,\n        accountRentExempt,\n        bidderPot,\n        bidderPotToken,\n        bidderMeta,\n        auction,\n        auctionExtended,\n        auctionTokenMint,\n        vault\n      });\n    } else {\n      const account = Keypair.generate();\n      const createBidderPotTransaction = new CreateTokenAccount({\n        feePayer: bidder\n      }, {\n        newAccountPubkey: account.publicKey,\n        lamports: accountRentExempt,\n        mint: auctionTokenMint,\n        owner: auction\n      });\n      txBatch.addSigner(account);\n      txBatch.addTransaction(createBidderPotTransaction);\n      bidderPotToken = account.publicKey;\n    }\n\n    const {\n      account: payingAccount,\n      createTokenAccountTx,\n      closeTokenAccountTx\n    } = yield createWrappedAccountTxs(connection, bidder, amount.toNumber() + accountRentExempt * 2);\n    txBatch.addTransaction(createTokenAccountTx);\n    txBatch.addAfterTransaction(closeTokenAccountTx);\n    txBatch.addSigner(payingAccount);\n    const {\n      authority: transferAuthority,\n      createApproveTx,\n      createRevokeTx\n    } = createApproveTxs({\n      account: payingAccount.publicKey,\n      owner: bidder,\n      amount: amount.toNumber()\n    });\n    txBatch.addTransaction(createApproveTx);\n    txBatch.addAfterTransaction(createRevokeTx);\n    txBatch.addSigner(transferAuthority);\n    const placeBidTransaction = new PlaceBid({\n      feePayer: bidder\n    }, {\n      bidder,\n      bidderToken: payingAccount.publicKey,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      tokenMint: auctionTokenMint,\n      transferAuthority: transferAuthority.publicKey,\n      amount,\n      resource: vault\n    });\n    txBatch.addTransaction(placeBidTransaction);\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txBatch.toTransactions(),\n      signers: txBatch.signers\n    });\n    return {\n      txId,\n      bidderPotToken,\n      bidderMeta\n    };\n  });\n};\n\nconst redeemFullRightsTransferBid = _ref16 => {\n  let {\n    connection,\n    wallet,\n    store,\n    auction\n  } = _ref16;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const bidder = wallet.publicKey;\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n    const auctionManager = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManager);\n    const vault = yield Vault.load(connection, manager.data.vault);\n    const fractionMint = new PublicKey(vault.data.fractionMint);\n    const auctionExtended = yield AuctionExtended.getPDA(vault.pubkey);\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\n    const tokenMint = new PublicKey(safetyDepositBox.data.tokenMint);\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\n    const bidRedemption = yield getBidRedemptionPDA(auction, bidderMeta);\n    const safetyDepositConfig = yield SafetyDepositConfig.getPDA(auctionManager, safetyDepositBox.pubkey);\n    const transferAuthority = yield Vault.getPDA(vault.pubkey);\n    const metadata = yield Metadata.getPDA(tokenMint);\n    const txBatch = yield getRedeemFRTBidTransactions({\n      accountRentExempt,\n      tokenMint,\n      bidder,\n      bidderMeta,\n      store,\n      vault: vault.pubkey,\n      auction,\n      auctionExtended,\n      auctionManager,\n      fractionMint,\n      safetyDepositTokenStore,\n      safetyDeposit: safetyDepositBox.pubkey,\n      bidRedemption,\n      safetyDepositConfig,\n      transferAuthority,\n      metadata\n    });\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txBatch.toTransactions(),\n      signers: txBatch.signers\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst getRedeemFRTBidTransactions = _ref17 => {\n  let {\n    accountRentExempt,\n    bidder,\n    tokenMint,\n    store,\n    vault,\n    auction,\n    auctionManager,\n    auctionExtended,\n    bidRedemption,\n    bidderMeta: bidMetadata,\n    safetyDepositTokenStore,\n    safetyDeposit,\n    fractionMint,\n    safetyDepositConfig,\n    transferAuthority,\n    metadata\n  } = _ref17;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const account = Keypair.generate();\n    const createDestinationTransaction = new CreateTokenAccount({\n      feePayer: bidder\n    }, {\n      newAccountPubkey: account.publicKey,\n      lamports: accountRentExempt,\n      mint: tokenMint\n    });\n    txBatch.addSigner(account);\n    txBatch.addTransaction(createDestinationTransaction);\n    const redeemBidTransaction = new RedeemFullRightsTransferBid({\n      feePayer: bidder\n    }, {\n      store,\n      vault,\n      auction,\n      auctionManager,\n      bidRedemption,\n      bidMetadata,\n      safetyDepositTokenStore,\n      destination: account.publicKey,\n      safetyDeposit,\n      fractionMint,\n      bidder,\n      safetyDepositConfig,\n      auctionExtended,\n      transferAuthority,\n      newAuthority: bidder,\n      masterMetadata: metadata\n    });\n    txBatch.addTransaction(redeemBidTransaction);\n    const updatePrimarySaleHappenedViaTokenTransaction = new UpdatePrimarySaleHappenedViaToken({\n      feePayer: bidder\n    }, {\n      metadata,\n      owner: bidder,\n      tokenAccount: account.publicKey\n    });\n    txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTransaction);\n    return txBatch;\n  });\n};\n\nconst getBidRedemptionPDA = (auction, bidderMeta) => __awaiter(void 0, void 0, void 0, function* () {\n  return (yield PublicKey.findProgramAddress([Buffer.from(MetaplexProgram.PREFIX), auction.toBuffer(), bidderMeta.toBuffer()], MetaplexProgram.PUBKEY))[0];\n});\n\nconst redeemPrintingV2Bid = _ref18 => {\n  let {\n    connection,\n    wallet,\n    store,\n    auction\n  } = _ref18;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const bidder = wallet.publicKey;\n    const {\n      data: {\n        bidState\n      }\n    } = yield Auction.load(connection, auction);\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\n    const vault = yield Vault.load(connection, manager.data.vault);\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\n    const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n    const bidderMetaPDA = yield BidderMetadata.getPDA(auction, bidder);\n    const bidRedemptionPDA = yield getBidRedemptionPDA(auction, bidderMetaPDA);\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n    const {\n      mint,\n      createMintTx,\n      createAssociatedTokenAccountTx,\n      mintToTx,\n      recipient\n    } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n    const newMint = mint.publicKey;\n    const newMetadataPDA = yield Metadata.getPDA(newMint);\n    const newEditionPDA = yield Edition.getPDA(newMint);\n    const metadataPDA = yield Metadata.getPDA(originalMint);\n    const masterEditionPDA = yield MasterEdition.getPDA(originalMint);\n    const masterEdition = yield MasterEdition.load(connection, masterEditionPDA);\n    const prizeTrackingTicketPDA = yield PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n    let prizeTrackingTicket;\n\n    try {\n      prizeTrackingTicket = yield PrizeTrackingTicket.load(connection, prizeTrackingTicketPDA);\n    } catch (e) {\n      prizeTrackingTicket = null;\n    }\n\n    const winIndex = bidState.getWinnerIndex(bidder.toBase58()) || 0;\n    const editionOffset = getEditionOffset(winIndex);\n    const editionBase = (prizeTrackingTicket === null || prizeTrackingTicket === void 0 ? void 0 : prizeTrackingTicket.data.supplySnapshot) || masterEdition.data.supply;\n    const desiredEdition = editionBase.add(editionOffset);\n    const editionMarkerPDA = yield EditionMarker.getPDA(originalMint, desiredEdition);\n\n    try {\n      const editionMarker = yield EditionMarker.load(connection, editionMarkerPDA);\n      const isEditionTaken = editionMarker.data.editionTaken(desiredEdition.toNumber());\n\n      if (isEditionTaken) {\n        throw new Error('The edition is already taken');\n      }\n    } catch (e) {}\n\n    const txBatch = yield getRedeemPrintingV2BidTransactions({\n      bidder,\n      bidderMeta: bidderMetaPDA,\n      store,\n      vault: vault.pubkey,\n      destination: recipient,\n      auction,\n      auctionExtended: auctionExtendedPDA,\n      auctionManager: auctionManagerPDA,\n      safetyDepositTokenStore,\n      safetyDeposit: safetyDepositBox.pubkey,\n      bidRedemption: bidRedemptionPDA,\n      safetyDepositConfig: safetyDepositConfigPDA,\n      metadata: metadataPDA,\n      newMint,\n      newMetadata: newMetadataPDA,\n      newEdition: newEditionPDA,\n      masterEdition: masterEditionPDA,\n      editionMarker: editionMarkerPDA,\n      prizeTrackingTicket: prizeTrackingTicketPDA,\n      editionOffset,\n      winIndex: new BN(winIndex)\n    });\n    txBatch.addSigner(mint);\n    txBatch.addBeforeTransaction(createMintTx);\n    txBatch.addBeforeTransaction(createAssociatedTokenAccountTx);\n    txBatch.addBeforeTransaction(mintToTx);\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txBatch.toTransactions(),\n      signers: txBatch.signers\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst getRedeemPrintingV2BidTransactions = _ref19 => {\n  let {\n    bidder,\n    destination,\n    store,\n    vault,\n    auction,\n    auctionManager,\n    auctionExtended,\n    bidRedemption,\n    bidderMeta: bidMetadata,\n    safetyDepositTokenStore,\n    safetyDeposit,\n    safetyDepositConfig,\n    metadata,\n    newMint,\n    newMetadata,\n    newEdition,\n    masterEdition,\n    editionMarker: editionMark,\n    prizeTrackingTicket,\n    winIndex,\n    editionOffset\n  } = _ref19;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const redeemPrintingV2BidTx = new RedeemPrintingV2Bid({\n      feePayer: bidder\n    }, {\n      store,\n      vault,\n      auction,\n      auctionManager,\n      bidRedemption,\n      bidMetadata,\n      safetyDepositTokenStore,\n      destination,\n      safetyDeposit,\n      bidder,\n      safetyDepositConfig,\n      auctionExtended,\n      newMint,\n      newEdition,\n      newMetadata,\n      metadata,\n      masterEdition,\n      editionMark,\n      prizeTrackingTicket,\n      winIndex,\n      editionOffset\n    });\n    txBatch.addTransaction(redeemPrintingV2BidTx);\n    const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({\n      feePayer: bidder\n    }, {\n      metadata: newMetadata,\n      owner: bidder,\n      tokenAccount: destination\n    });\n    txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n    return txBatch;\n  });\n};\n\nfunction getEditionOffset(winIndex) {\n  const offset = new BN(1);\n  return offset.add(new BN(winIndex));\n}\n\nconst redeemParticipationBidV3 = _ref20 => {\n  let {\n    connection,\n    wallet,\n    store,\n    auction\n  } = _ref20;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txInitBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const txMainBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const bidder = wallet.publicKey;\n    const {\n      data: {\n        bidState,\n        tokenMint: auctionTokenMint\n      }\n    } = yield Auction.load(connection, auction);\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\n    const vault = yield Vault.load(connection, manager.data.vault);\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\n    const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n    const bidderMetaPDA = yield BidderMetadata.getPDA(auction, bidder);\n    const bidRedemptionPDA = yield getBidRedemptionPDA(auction, bidderMetaPDA);\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n    const {\n      data: {\n        participationConfig: {\n          fixedPrice\n        }\n      }\n    } = yield SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n    const acceptPaymentAccount = new PublicKey(manager.data.acceptPayment);\n    const {\n      mint,\n      createMintTx,\n      createAssociatedTokenAccountTx,\n      mintToTx,\n      recipient\n    } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n    txInitBatch.addSigner(mint);\n    txInitBatch.addTransaction(createMintTx);\n    txInitBatch.addTransaction(createAssociatedTokenAccountTx);\n    txInitBatch.addTransaction(mintToTx);\n    const newMint = mint.publicKey;\n    const newMetadataPDA = yield Metadata.getPDA(newMint);\n    const newEditionPDA = yield Edition.getPDA(newMint);\n    const metadataPDA = yield Metadata.getPDA(originalMint);\n    const masterEditionPDA = yield MasterEdition.getPDA(originalMint);\n    const masterEdition = yield MasterEdition.load(connection, masterEditionPDA);\n    const prizeTrackingTicketPDA = yield PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n    const winIndex = bidState.getWinnerIndex(bidder.toBase58());\n    const desiredEdition = masterEdition.data.supply.add(new BN(1));\n    const editionMarkerPDA = yield EditionMarker.getPDA(originalMint, desiredEdition);\n    let tokenPaymentAccount;\n\n    if (auctionTokenMint === NATIVE_MINT.toBase58()) {\n      const {\n        account,\n        createTokenAccountTx,\n        closeTokenAccountTx\n      } = yield createWrappedAccountTxs(connection, bidder, fixedPrice.toNumber());\n      tokenPaymentAccount = account.publicKey;\n      txInitBatch.addTransaction(createTokenAccountTx);\n      txInitBatch.addSigner(account);\n      txMainBatch.addAfterTransaction(closeTokenAccountTx);\n    } else {\n      tokenPaymentAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new PublicKey(auctionTokenMint), bidder);\n    }\n\n    const {\n      authority,\n      createApproveTx,\n      createRevokeTx\n    } = createApproveTxs({\n      account: tokenPaymentAccount,\n      owner: bidder,\n      amount: fixedPrice.toNumber()\n    });\n    txMainBatch.addTransaction(createApproveTx);\n    txMainBatch.addAfterTransaction(createRevokeTx);\n    txMainBatch.addSigner(authority);\n    const redeemParticipationBidV3Tx = new RedeemParticipationBidV3({\n      feePayer: bidder\n    }, {\n      store,\n      vault: vault.pubkey,\n      auction,\n      auctionManager: auctionManagerPDA,\n      bidRedemption: bidRedemptionPDA,\n      bidMetadata: bidderMetaPDA,\n      safetyDepositTokenStore,\n      destination: recipient,\n      safetyDeposit: safetyDepositBox.pubkey,\n      bidder,\n      safetyDepositConfig: safetyDepositConfigPDA,\n      auctionExtended: auctionExtendedPDA,\n      newMint,\n      newEdition: newEditionPDA,\n      newMetadata: newMetadataPDA,\n      metadata: metadataPDA,\n      masterEdition: masterEditionPDA,\n      editionMark: editionMarkerPDA,\n      prizeTrackingTicket: prizeTrackingTicketPDA,\n      winIndex: winIndex !== null ? new BN(winIndex) : null,\n      transferAuthority: authority.publicKey,\n      tokenPaymentAccount,\n      acceptPaymentAccount\n    });\n    txMainBatch.addTransaction(redeemParticipationBidV3Tx);\n    const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({\n      feePayer: bidder\n    }, {\n      metadata: newMetadataPDA,\n      owner: bidder,\n      tokenAccount: recipient\n    });\n    txMainBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n    const initTxId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txInitBatch.toTransactions(),\n      signers: txInitBatch.signers\n    });\n    yield connection.confirmTransaction(initTxId, 'finalized');\n    const mainTxId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txMainBatch.toTransactions(),\n      signers: txMainBatch.signers\n    });\n    return {\n      txIds: [initTxId, mainTxId]\n    };\n  });\n};\n\nfunction isEligibleForParticipationPrize(winIndex) {\n  let {\n    nonWinningConstraint,\n    winnerConstraint\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const noWinnerConstraints = winnerConstraint !== WinningConstraint.NoParticipationPrize;\n  const noNonWinnerConstraints = nonWinningConstraint !== NonWinningConstraint.NoParticipationPrize;\n  return winIndex === null && noNonWinnerConstraints || winIndex !== null && noWinnerConstraints;\n}\n\nconst claimBid = _ref21 => {\n  let {\n    connection,\n    wallet,\n    store,\n    auction,\n    bidderPotToken\n  } = _ref21;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const bidder = wallet.publicKey;\n    const auctionManager = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManager);\n    const vault = new PublicKey(manager.data.vault);\n    const {\n      data: {\n        tokenMint\n      }\n    } = yield Auction.load(connection, auction);\n    const acceptPayment = new PublicKey(manager.data.acceptPayment);\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\n    const auctionTokenMint = new PublicKey(tokenMint);\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\n    const txBatch = yield getClaimBidTransactions({\n      auctionTokenMint,\n      bidder,\n      store,\n      vault,\n      auction,\n      auctionExtended,\n      auctionManager,\n      acceptPayment,\n      bidderPot,\n      bidderPotToken\n    });\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: txBatch.toTransactions(),\n      signers: txBatch.signers\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst getClaimBidTransactions = _ref22 => {\n  let {\n    bidder,\n    auctionTokenMint,\n    store,\n    vault,\n    auction,\n    auctionManager,\n    auctionExtended,\n    acceptPayment,\n    bidderPot,\n    bidderPotToken\n  } = _ref22;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txBatch = new TransactionsBatch({\n      transactions: []\n    });\n    const claimBidTransaction = new ClaimBid({\n      feePayer: bidder\n    }, {\n      store,\n      vault,\n      auction,\n      auctionExtended,\n      auctionManager,\n      bidder,\n      tokenMint: auctionTokenMint,\n      acceptPayment,\n      bidderPot,\n      bidderPotToken\n    });\n    txBatch.addTransaction(claimBidTransaction);\n    return txBatch;\n  });\n};\n\nconst instantSale = _ref23 => {\n  let {\n    connection,\n    wallet,\n    store,\n    auction\n  } = _ref23;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txIds = [];\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\n    const vault = yield Vault.load(connection, manager.data.vault);\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\n    const {\n      data: {\n        instantSalePrice\n      }\n    } = yield AuctionExtended.load(connection, auctionExtendedPDA);\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n    const {\n      data: {\n        winningConfigType,\n        participationConfig\n      }\n    } = yield SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n    const {\n      txId: placeBidTxId,\n      bidderPotToken\n    } = yield placeBid({\n      connection,\n      wallet,\n      amount: instantSalePrice,\n      auction\n    });\n    txIds.push(placeBidTxId);\n    yield connection.confirmTransaction(placeBidTxId, 'finalized');\n    const {\n      data: {\n        bidState\n      }\n    } = yield Auction.load(connection, auction);\n    const winIndex = bidState.getWinnerIndex(wallet.publicKey.toBase58());\n    const hasWinner = winIndex !== null;\n\n    if (hasWinner) {\n      switch (winningConfigType) {\n        case WinningConfigType.FullRightsTransfer:\n          {\n            const {\n              txId\n            } = yield redeemFullRightsTransferBid({\n              connection,\n              wallet,\n              store,\n              auction\n            });\n            txIds.push(txId);\n            break;\n          }\n\n        case WinningConfigType.PrintingV2:\n          {\n            const {\n              txId\n            } = yield redeemPrintingV2Bid({\n              connection,\n              wallet,\n              store,\n              auction\n            });\n            txIds.push(txId);\n            break;\n          }\n\n        default:\n          throw new Error(`${winningConfigType} winning type isn't supported yet`);\n      }\n\n      const {\n        txId: claimBidTxId\n      } = yield claimBid({\n        connection,\n        wallet,\n        store,\n        auction,\n        bidderPotToken\n      });\n      txIds.push(claimBidTxId);\n    } else {\n      const {\n        txId\n      } = yield cancelBid({\n        connection,\n        wallet,\n        auction,\n        bidderPotToken\n      });\n      txIds.push(txId);\n    }\n\n    const hasWonParticipationPrize = isEligibleForParticipationPrize(winIndex, participationConfig);\n\n    if (hasWonParticipationPrize) {\n      const {\n        txIds\n      } = yield redeemParticipationBidV3({\n        connection,\n        wallet,\n        store,\n        auction\n      });\n      txIds.push(...txIds);\n    }\n\n    return {\n      txIds: txIds\n    };\n  });\n};\n\nconst burnToken = _ref24 => {\n  let {\n    connection,\n    wallet,\n    token,\n    mint,\n    amount,\n    owner,\n    close = true\n  } = _ref24;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const tx = new Transaction({\n      feePayer: wallet.publicKey\n    }).add(Token.createBurnInstruction(TOKEN_PROGRAM_ID, mint, token, owner !== null && owner !== void 0 ? owner : wallet.publicKey, [], amount));\n\n    if (close) {\n      tx.add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, token, wallet.publicKey, owner !== null && owner !== void 0 ? owner : wallet.publicKey, []));\n    }\n\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs: [tx]\n    });\n    return {\n      txId\n    };\n  });\n};\n\nconst sendToken = _ref25 => {\n  let {\n    connection,\n    wallet,\n    source,\n    destination,\n    mint,\n    amount\n  } = _ref25;\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const txs = [];\n    const destAta = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, destination);\n    const transactionCtorFields = {\n      feePayer: wallet.publicKey\n    };\n\n    try {\n      yield Account.load(connection, destAta);\n    } catch (_a) {\n      txs.push(new CreateAssociatedTokenAccount(transactionCtorFields, {\n        associatedTokenAddress: destAta,\n        splTokenMintAddress: mint,\n        walletAddress: destination\n      }));\n    }\n\n    txs.push(new Transaction(transactionCtorFields).add(Token.createTransferInstruction(TOKEN_PROGRAM_ID, source, destAta, wallet.publicKey, [], amount)));\n    const txId = yield sendTransaction({\n      connection,\n      wallet,\n      txs\n    });\n    return {\n      txId\n    };\n  });\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sendTransaction: sendTransaction,\n  initStore: initStore,\n  initStoreV2: initStoreV2,\n  mintNFT: mintNFT,\n  mintEditionFromMaster: mintEditionFromMaster,\n  closeVault: closeVault,\n  createVault: createVault,\n  createExternalPriceAccount: createExternalPriceAccount,\n  createMetadata: createMetadata,\n  createMasterEdition: createMasterEdition,\n  signMetadata: signMetadata,\n  updateMetadata: updateMetadata,\n  cancelBid: cancelBid,\n  getCancelBidTransactions: getCancelBidTransactions,\n  placeBid: placeBid,\n  redeemFullRightsTransferBid: redeemFullRightsTransferBid,\n  getRedeemFRTBidTransactions: getRedeemFRTBidTransactions,\n  getBidRedemptionPDA: getBidRedemptionPDA,\n  redeemPrintingV2Bid: redeemPrintingV2Bid,\n  getRedeemPrintingV2BidTransactions: getRedeemPrintingV2BidTransactions,\n  getEditionOffset: getEditionOffset,\n  redeemParticipationBidV3: redeemParticipationBidV3,\n  isEligibleForParticipationPrize: isEligibleForParticipationPrize,\n  claimBid: claimBid,\n  getClaimBidTransactions: getClaimBidTransactions,\n  instantSale: instantSale,\n  burnToken: burnToken,\n  sendToken: sendToken,\n  prepareTokenAccountAndMintTxs: prepareTokenAccountAndMintTxs,\n  createWrappedAccountTxs: createWrappedAccountTxs,\n  createApproveTxs: createApproveTxs\n});\nexport { ArweaveStorage, ChainId, Coingecko, Connection, Currency, ENV, NodeWallet, index as actions, index$1 as programs, index$2 as utils };","map":{"version":3,"sources":["../src/providers/conversion/ConversionRateProvider.ts","../src/providers/conversion/Coingecko.ts","../node_modules/form-data/lib/browser.js","../src/providers/storage/arweave/ArweaveStorage.ts","../src/Connection.ts","../src/wallet/index.ts","../src/utils/crypto.ts","../src/utils/metadata.ts","../src/actions/transactions.ts","../src/actions/initStore.ts","../src/actions/initStoreV2.ts","../src/programs/shared/transactions/PayForFiles.ts","../src/programs/shared/transactions/CreateMint.ts","../src/programs/shared/transactions/CreateTokenAccount.ts","../src/programs/shared/transactions/CreateAssociatedTokenAccount.ts","../src/programs/shared/transactions/MintTo.ts","../src/actions/shared/mint.ts","../src/actions/shared/wrapped-account.ts","../src/actions/shared/approve.ts","../src/actions/mintNFT.ts","../src/actions/mintEditionFromMaster.ts","../src/utils/transactions-batch.ts","../src/actions/closeVault.ts","../src/actions/createVault.ts","../src/actions/createExternalPriceAccount.ts","../src/actions/createMetadata.ts","../src/actions/createMasterEdition.ts","../src/actions/signMetadata.ts","../src/actions/updateMetadata.ts","../src/actions/cancelBid.ts","../src/actions/placeBid.ts","../src/actions/redeemFullRightsTransferBid.ts","../src/actions/redeemPrintingV2Bid.ts","../src/actions/redeemParticipationBidV3.ts","../src/actions/claimBid.ts","../src/actions/instantSale.ts","../src/actions/burnToken.ts","../src/actions/sendToken.ts"],"names":["FormData","SolanaConnection","Buffer","Transaction"],"mappings":"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","sourcesContent":["// We are keeping an organized enum of all currencies to allow for easier refactoring should\n// we decide to change the way that metaplex names currencies internally\nexport enum Currency {\n  USD = 'usd',\n  EUR = 'eur',\n  AR = 'ar',\n  SOL = 'sol',\n}\n\nexport type ConversionRatePair = {\n  from: Currency;\n  to: Currency;\n  rate: number;\n};\n\nexport interface ConversionRateProvider {\n  getRate(from: Currency | Currency[], to: Currency | Currency[]): Promise<ConversionRatePair[]>;\n}\n","import { ConversionRateProvider, Currency, ConversionRatePair } from './ConversionRateProvider';\nimport axios from 'axios';\n\nexport class Coingecko implements ConversionRateProvider {\n  // this method translates currency strings to the format that coingecko requires\n  static translateCurrency(currency: Currency): string {\n    switch (currency) {\n      case Currency.AR:\n        return 'arweave';\n      case Currency.SOL:\n        return 'solana';\n      case Currency.USD:\n        return 'usd';\n      case Currency.EUR:\n        return 'eur';\n      default:\n        throw new Error('Invalid currency supplied to Coingecko conversion rate provider');\n    }\n  }\n\n  async getRate(from: Currency | Currency[], to: Currency | Currency[]) {\n    const fromArray = typeof from === 'string' ? [from] : from;\n    const toArray = typeof to === 'string' ? [to] : to;\n    const fromIds = fromArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');\n    const toIds = toArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');\n    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromIds}&vs_currencies=${toIds}`;\n    const response = await axios(url);\n    const data = await response.data;\n    return fromArray.reduce<ConversionRatePair[]>((previousPairs, fromCurrency) => {\n      return [\n        ...previousPairs,\n        ...toArray.map((toCurrency) => ({\n          from: fromCurrency,\n          to: toCurrency,\n          rate: data[Coingecko.translateCurrency(fromCurrency)][\n            Coingecko.translateCurrency(toCurrency)\n          ],\n        })),\n      ];\n    }, []);\n  }\n}\n","/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n","import { Storage, UploadResult } from '../Storage';\nimport { Buffer } from 'buffer';\nimport axios from 'axios';\nimport FormData from 'form-data';\n\nconst ARWEAVE_URL = 'https://arweave.net';\nconst LAMPORT_MULTIPLIER = 10 ** 9;\nconst WINSTON_MULTIPLIER = 10 ** 12;\n\nexport interface ArweaveUploadResult extends UploadResult {\n  messages?: {\n    filename: string;\n    status: 'success' | 'fail';\n    transactionId?: string;\n    error?: string;\n  }[];\n}\n\nexport interface ArweaveStorageCtorFields {\n  endpoint: string;\n  env: 'mainnet-beta' | 'testnet' | 'devnet';\n}\n\nexport class ArweaveStorage implements Storage {\n  readonly endpoint: string;\n  readonly env: string;\n\n  constructor({ endpoint, env }: ArweaveStorageCtorFields) {\n    this.endpoint = endpoint;\n    this.env = env;\n  }\n\n  async getAssetCostToStore(files: Map<string, Buffer>, arweaveRate: number, solanaRate: number) {\n    const buffers = Array.from(files.values());\n    const totalBytes = buffers.reduce((sum, f) => (sum += f.byteLength), 0);\n    const txnFeeInWinstons = parseInt(await (await axios(`${ARWEAVE_URL}/price/0`)).data);\n    const byteCostInWinstons = parseInt(\n      await (\n        await axios(`${ARWEAVE_URL}/price/${totalBytes.toString()}`)\n      ).data,\n    );\n    const totalArCost =\n      (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;\n    // To figure out how many lamports are required, multiply ar byte cost by this number\n    const arMultiplier = arweaveRate / solanaRate;\n    // We also always make a manifest file, which, though tiny, needs payment.\n    return LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1;\n  }\n\n  async upload(\n    files: Map<string, Buffer>,\n    mintKey: string,\n    txid: string,\n  ): Promise<ArweaveUploadResult> {\n    const fileEntries = Array.from(files.entries());\n    const tags = fileEntries.reduce(\n      (acc: Record<string, Array<{ name: string; value: string }>>, [fileName]) => {\n        acc[fileName] = [{ name: 'mint', value: mintKey }];\n        return acc;\n      },\n      {},\n    );\n\n    const body = new FormData();\n\n    body.append('tags', JSON.stringify(tags));\n    body.append('transaction', txid);\n    body.append('env', this.env);\n    fileEntries.map(([, file]) => {\n      body.append('file[]', file);\n    });\n\n    // TODO: I hate to do this, but it seems to be like an upstream problem:\n    // https://github.com/jimmywarting/FormData/issues/133\n    // I'll make sure to track it. - Danny\n    const response = await axios.post(this.endpoint, body);\n\n    if (response.data.error) {\n      return Promise.reject(new Error(response.data.error));\n    }\n\n    return response.data;\n  }\n}\n","import { clusterApiUrl, Commitment, Connection as SolanaConnection } from '@solana/web3.js';\n\nexport enum ChainId {\n  MainnetBeta = 101,\n  Testnet = 102,\n  Devnet = 103,\n}\n\nexport const ENV: Record<string, { endpoint: string; ChainId: ChainId }> = {\n  devnet: {\n    endpoint: clusterApiUrl('devnet'),\n    ChainId: ChainId.Devnet,\n  },\n  'mainnet-beta': {\n    endpoint: 'https://api.metaplex.solana.com/',\n    ChainId: ChainId.MainnetBeta,\n  },\n  'mainnet-beta (Solana)': {\n    endpoint: 'https://api.mainnet-beta.solana.com',\n    ChainId: ChainId.MainnetBeta,\n  },\n  'mainnet-beta (Serum)': {\n    endpoint: 'https://solana-api.projectserum.com/',\n    ChainId: ChainId.MainnetBeta,\n  },\n  testnet: {\n    endpoint: clusterApiUrl('testnet'),\n    ChainId: ChainId.Testnet,\n  },\n};\n\nexport class Connection extends SolanaConnection {\n  constructor(endpoint: keyof typeof ENV | string = 'mainnet-beta', commitment?: Commitment) {\n    if (endpoint in ENV) endpoint = ENV[endpoint].endpoint;\n    super(endpoint, commitment);\n  }\n}\n","import { Keypair, PublicKey, Transaction } from '@solana/web3.js';\n\nexport interface Wallet {\n  publicKey: PublicKey;\n  signTransaction(tx: Transaction): Promise<Transaction>;\n  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;\n}\n\nexport class NodeWallet implements Wallet {\n  constructor(readonly payer: Keypair) {}\n\n  async signTransaction(tx: Transaction): Promise<Transaction> {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n\n  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {\n    return txs.map((tx) => {\n      tx.partialSign(this.payer);\n      return tx;\n    });\n  }\n\n  get publicKey(): PublicKey {\n    return this.payer.publicKey;\n  }\n}\n","import { sha256 } from 'crypto-hash';\nimport { Buffer } from 'buffer';\n\nexport const getFileHash = async (file: Buffer) => Buffer.from(await sha256(file.toString()));\n","import axios, { AxiosResponse } from 'axios';\nimport { MetadataJson } from './../types';\n\nexport const lookup = async (url: string): Promise<MetadataJson> => {\n  try {\n    const { data } = await axios.get<string, AxiosResponse<MetadataJson>>(url);\n\n    return data;\n  } catch {\n    throw new Error(`unable to get metadata json from url ${url}`);\n  }\n};\n","import { Keypair, SendOptions } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ninterface ISendTransactionParams {\n  connection: Connection;\n  wallet: Wallet;\n  txs: Transaction[];\n  signers?: Keypair[];\n  options?: SendOptions;\n}\n\nexport const sendTransaction = async ({\n  connection,\n  wallet,\n  txs,\n  signers = [],\n  options,\n}: ISendTransactionParams): Promise<string> => {\n  let tx = Transaction.fromCombined(txs, { feePayer: wallet.publicKey });\n  tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;\n\n  if (signers.length) {\n    tx.partialSign(...signers);\n  }\n  tx = await wallet.signTransaction(tx);\n\n  return connection.sendRawTransaction(tx.serialize(), options);\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { SetStore, Store } from '@metaplex-foundation/mpl-metaplex';\n\ninterface IInitStoreParams {\n  connection: Connection;\n  wallet: Wallet;\n  isPublic?: boolean;\n}\n\ninterface IInitStoreResponse {\n  storeId: PublicKey;\n  txId: string;\n}\n\nexport const initStore = async ({\n  connection,\n  wallet,\n  isPublic = true,\n}: IInitStoreParams): Promise<IInitStoreResponse> => {\n  const storeId = await Store.getPDA(wallet.publicKey);\n  const tx = new SetStore(\n    { feePayer: wallet.publicKey },\n    {\n      admin: new PublicKey(wallet.publicKey),\n      store: storeId,\n      isPublic,\n    },\n  );\n\n  const txId = await sendTransaction({ connection, wallet, txs: [tx] });\n\n  return { storeId, txId };\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { SetStoreV2, Store, StoreConfig } from '@metaplex-foundation/mpl-metaplex';\n\ninterface IInitStoreV2Params {\n  connection: Connection;\n  wallet: Wallet;\n  isPublic?: boolean;\n  settingsUri?: string | null;\n}\n\ninterface IInitStoreV2Response {\n  storeId: PublicKey;\n  configId: PublicKey;\n  txId: string;\n}\n\nexport const initStoreV2 = async ({\n  connection,\n  wallet,\n  settingsUri = null,\n  isPublic = true,\n}: IInitStoreV2Params): Promise<IInitStoreV2Response> => {\n  const storeId = await Store.getPDA(wallet.publicKey);\n  const configId = await StoreConfig.getPDA(storeId);\n  const tx = new SetStoreV2(\n    { feePayer: wallet.publicKey },\n    {\n      admin: new PublicKey(wallet.publicKey),\n      store: storeId,\n      config: configId,\n      isPublic,\n      settingsUri,\n    },\n  );\n\n  const txId = await sendTransaction({ connection, wallet, txs: [tx] });\n\n  return { storeId, configId, txId };\n};\n","import { Transaction } from '@metaplex-foundation/mpl-core';\nimport {\n  PublicKey,\n  SystemProgram,\n  TransactionCtorFields,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { config } from '@metaplex-foundation/mpl-core';\nimport { Buffer } from 'buffer';\n\ntype PayForFilesParams = {\n  lamports: number;\n  fileHashes: Buffer[];\n  arweaveWallet?: PublicKey;\n};\n\nexport class PayForFiles extends Transaction {\n  constructor(options: TransactionCtorFields, params: PayForFilesParams) {\n    const { feePayer } = options;\n    const { lamports, fileHashes, arweaveWallet } = params;\n\n    super(options);\n\n    this.add(\n      SystemProgram.transfer({\n        fromPubkey: feePayer,\n        toPubkey: arweaveWallet ?? new PublicKey(config.arweaveWallet),\n        lamports,\n      }),\n    );\n\n    fileHashes.forEach((data) => {\n      this.add(\n        new TransactionInstruction({\n          keys: [],\n          programId: new PublicKey(config.programs.memo),\n          data,\n        }),\n      );\n    });\n  }\n}\n","import { Transaction } from '@metaplex-foundation/mpl-core';\nimport { MintLayout, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { PublicKey, SystemProgram, TransactionCtorFields } from '@solana/web3.js';\n\ntype CreateMintParams = {\n  newAccountPubkey: PublicKey;\n  lamports: number;\n  decimals?: number;\n  owner?: PublicKey;\n  freezeAuthority?: PublicKey;\n};\n\nexport class CreateMint extends Transaction {\n  constructor(options: TransactionCtorFields, params: CreateMintParams) {\n    const { feePayer } = options;\n    const { newAccountPubkey, lamports, decimals, owner, freezeAuthority } = params;\n\n    super(options);\n\n    this.add(\n      SystemProgram.createAccount({\n        fromPubkey: feePayer,\n        newAccountPubkey,\n        lamports,\n        space: MintLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n\n    this.add(\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        newAccountPubkey,\n        decimals ?? 0,\n        owner ?? feePayer,\n        freezeAuthority ?? feePayer,\n      ),\n    );\n  }\n}\n","import { Transaction } from '@metaplex-foundation/mpl-core';\nimport { AccountLayout, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { PublicKey, SystemProgram, TransactionCtorFields } from '@solana/web3.js';\n\ntype CreateTokenAccountParams = {\n  newAccountPubkey: PublicKey;\n  lamports: number;\n  mint: PublicKey;\n  owner?: PublicKey;\n};\n\nexport class CreateTokenAccount extends Transaction {\n  constructor(options: TransactionCtorFields, params: CreateTokenAccountParams) {\n    const { feePayer } = options;\n    const { newAccountPubkey, lamports, mint, owner } = params;\n\n    super(options);\n\n    this.add(\n      SystemProgram.createAccount({\n        fromPubkey: feePayer,\n        newAccountPubkey,\n        lamports,\n        space: AccountLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n\n    this.add(\n      Token.createInitAccountInstruction(\n        TOKEN_PROGRAM_ID,\n        mint,\n        newAccountPubkey,\n        owner ?? feePayer,\n      ),\n    );\n  }\n}\n","import { Transaction } from '@metaplex-foundation/mpl-core';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport {\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  TransactionCtorFields,\n  TransactionInstruction,\n} from '@solana/web3.js';\nimport { Buffer } from 'buffer';\n\ntype CreateAssociatedTokenAccountParams = {\n  associatedTokenAddress: PublicKey;\n  walletAddress?: PublicKey;\n  splTokenMintAddress: PublicKey;\n};\n\nexport class CreateAssociatedTokenAccount extends Transaction {\n  constructor(options: TransactionCtorFields, params: CreateAssociatedTokenAccountParams) {\n    const { feePayer } = options;\n    const { associatedTokenAddress, walletAddress, splTokenMintAddress } = params;\n    super(options);\n\n    this.add(\n      new TransactionInstruction({\n        keys: [\n          {\n            pubkey: feePayer,\n            isSigner: true,\n            isWritable: true,\n          },\n          {\n            pubkey: associatedTokenAddress,\n            isSigner: false,\n            isWritable: true,\n          },\n          {\n            pubkey: walletAddress ?? feePayer,\n            isSigner: false,\n            isWritable: false,\n          },\n          {\n            pubkey: splTokenMintAddress,\n            isSigner: false,\n            isWritable: false,\n          },\n          {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false,\n          },\n          {\n            pubkey: TOKEN_PROGRAM_ID,\n            isSigner: false,\n            isWritable: false,\n          },\n          {\n            pubkey: SYSVAR_RENT_PUBKEY,\n            isSigner: false,\n            isWritable: false,\n          },\n        ],\n        programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n        data: Buffer.from([]),\n      }),\n    );\n  }\n}\n","import { Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { PublicKey, TransactionCtorFields } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ntype MintToParams = {\n  mint: PublicKey;\n  dest: PublicKey;\n  amount: number | BN;\n  authority?: PublicKey;\n};\n\nexport class MintTo extends Transaction {\n  constructor(options: TransactionCtorFields, params: MintToParams) {\n    const { feePayer } = options;\n    const { mint, dest, authority, amount } = params;\n\n    super(options);\n\n    this.add(\n      Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        mint,\n        dest,\n        authority ?? feePayer,\n        [],\n        new BN(amount).toNumber(),\n      ),\n    );\n  }\n}\n","import { Connection, Keypair, PublicKey } from '@solana/web3.js';\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from '@solana/spl-token';\nimport { CreateAssociatedTokenAccount, CreateMint, MintTo } from '../../programs';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ninterface MintTxs {\n  mint: Keypair;\n  // recipient ATA\n  recipient: PublicKey;\n  createMintTx: Transaction;\n  createAssociatedTokenAccountTx: Transaction;\n  mintToTx: Transaction;\n}\n\nexport async function prepareTokenAccountAndMintTxs(\n  connection: Connection,\n  owner: PublicKey,\n): Promise<MintTxs> {\n  const mint = Keypair.generate();\n  const mintRent = await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n  const createMintTx = new CreateMint(\n    { feePayer: owner },\n    {\n      newAccountPubkey: mint.publicKey,\n      lamports: mintRent,\n    },\n  );\n\n  const recipient = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint.publicKey,\n    owner,\n  );\n\n  const createAssociatedTokenAccountTx = new CreateAssociatedTokenAccount(\n    { feePayer: owner },\n    {\n      associatedTokenAddress: recipient,\n      splTokenMintAddress: mint.publicKey,\n    },\n  );\n\n  const mintToTx = new MintTo(\n    { feePayer: owner },\n    {\n      mint: mint.publicKey,\n      dest: recipient,\n      amount: 1,\n    },\n  );\n\n  return { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient };\n}\n","import { Transaction } from '@metaplex-foundation/mpl-core';\nimport { AccountLayout, NATIVE_MINT, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Connection, Keypair, PublicKey } from '@solana/web3.js';\nimport { CreateTokenAccount } from '../../programs/shared/transactions/CreateTokenAccount';\n\ninterface WrappedAccountTxs {\n  account: Keypair;\n  createTokenAccountTx: Transaction;\n  closeTokenAccountTx: Transaction;\n}\n\nexport async function createWrappedAccountTxs(\n  connection: Connection,\n  owner: PublicKey,\n  amount = 0,\n): Promise<WrappedAccountTxs> {\n  const account = Keypair.generate();\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const createTokenAccountTx = new CreateTokenAccount(\n    { feePayer: owner },\n    {\n      newAccountPubkey: account.publicKey,\n      lamports: amount + accountRentExempt,\n      mint: NATIVE_MINT,\n    },\n  );\n  const closeTokenAccountTx = new Transaction().add(\n    Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, owner, owner, []),\n  );\n  return { account, createTokenAccountTx, closeTokenAccountTx };\n}\n","import { Token, TOKEN_PROGRAM_ID, u64 } from '@solana/spl-token';\nimport { Keypair, PublicKey, Transaction } from '@solana/web3.js';\n\ninterface CreateApproveParams {\n  authority: Keypair;\n  account: PublicKey;\n  owner: PublicKey;\n  amount: number | u64;\n}\n\nexport function createApproveTxs(args: Optional<CreateApproveParams, 'authority'>) {\n  const { authority = Keypair.generate(), account, owner, amount } = args;\n\n  const createApproveTx = new Transaction().add(\n    Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      account,\n      authority.publicKey,\n      owner,\n      [],\n      amount,\n    ),\n  );\n  const createRevokeTx = new Transaction().add(\n    Token.createRevokeInstruction(TOKEN_PROGRAM_ID, account, owner, []),\n  );\n  return { authority, createApproveTx, createRevokeTx };\n}\n","import { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { Connection } from '../Connection';\nimport {\n  CreateMasterEdition,\n  CreateMetadata,\n  Creator,\n  MasterEdition,\n  Metadata,\n  MetadataDataData,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Wallet } from '../wallet';\nimport { sendTransaction } from './transactions';\nimport { lookup } from '../utils/metadata';\nimport { prepareTokenAccountAndMintTxs } from './shared';\n\ninterface MintNFTParams {\n  connection: Connection;\n  wallet: Wallet;\n  uri: string;\n  maxSupply?: number;\n}\n\ninterface MintNFTResponse {\n  txId: string;\n  mint: PublicKey;\n  metadata: PublicKey;\n  edition: PublicKey;\n}\n\nexport const mintNFT = async ({\n  connection,\n  wallet,\n  uri,\n  maxSupply,\n}: MintNFTParams): Promise<MintNFTResponse> => {\n  const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } =\n    await prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n  const metadataPDA = await Metadata.getPDA(mint.publicKey);\n  const editionPDA = await MasterEdition.getPDA(mint.publicKey);\n\n  const {\n    name,\n    symbol,\n    seller_fee_basis_points,\n    properties: { creators },\n  } = await lookup(uri);\n\n  const creatorsData = creators.reduce<Creator[]>((memo, { address, share }) => {\n    const verified = address === wallet.publicKey.toString();\n\n    const creator = new Creator({\n      address,\n      share,\n      verified,\n    });\n\n    memo = [...memo, creator];\n\n    return memo;\n  }, []);\n\n  const metadataData = new MetadataDataData({\n    name,\n    symbol,\n    uri,\n    sellerFeeBasisPoints: seller_fee_basis_points,\n    creators: creatorsData,\n  });\n\n  const createMetadataTx = new CreateMetadata(\n    {\n      feePayer: wallet.publicKey,\n    },\n    {\n      metadata: metadataPDA,\n      metadataData,\n      updateAuthority: wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey,\n    },\n  );\n\n  const masterEditionTx = new CreateMasterEdition(\n    { feePayer: wallet.publicKey },\n    {\n      edition: editionPDA,\n      metadata: metadataPDA,\n      updateAuthority: wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey,\n      maxSupply: maxSupply ? new BN(maxSupply) : null,\n    },\n  );\n\n  const txId = await sendTransaction({\n    connection,\n    signers: [mint],\n    txs: [\n      createMintTx,\n      createMetadataTx,\n      createAssociatedTokenAccountTx,\n      mintToTx,\n      masterEditionTx,\n    ],\n    wallet,\n  });\n\n  return {\n    txId,\n    mint: mint.publicKey,\n    metadata: metadataPDA,\n    edition: editionPDA,\n  };\n};\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Wallet } from '../wallet';\nimport {\n  Edition,\n  EditionMarker,\n  MasterEdition,\n  Metadata,\n  MintNewEditionFromMasterEditionViaToken,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Account } from '@metaplex-foundation/mpl-core';\nimport BN from 'bn.js';\nimport { prepareTokenAccountAndMintTxs } from './shared';\nimport { sendTransaction } from './transactions';\n\ninterface MintEditionFromMasterParams {\n  connection: Connection;\n  wallet: Wallet;\n  masterEditionMint: PublicKey;\n  updateAuthority?: PublicKey;\n}\n\ninterface MintEditionFromMasterResponse {\n  txId: string;\n  mint: PublicKey;\n  metadata: PublicKey;\n  edition: PublicKey;\n}\n\nexport const mintEditionFromMaster = async (\n  { connection, wallet, masterEditionMint, updateAuthority } = {} as MintEditionFromMasterParams,\n): Promise<MintEditionFromMasterResponse> => {\n  const masterPDA = await MasterEdition.getPDA(masterEditionMint);\n  const masterMetaPDA = await Metadata.getPDA(masterEditionMint);\n  const masterInfo = await Account.getInfo(connection, masterPDA);\n  const masterData = new MasterEdition(masterPDA, masterInfo).data;\n\n  //take the current outstanding supply and increment by 1\n  const editionValue = masterData.supply.add(new BN(1));\n\n  const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } =\n    await prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n  const tokenAccount = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    masterEditionMint,\n    wallet.publicKey,\n  );\n\n  const metadataPDA = await Metadata.getPDA(mint.publicKey);\n  const editionMarker = await EditionMarker.getPDA(masterEditionMint, editionValue);\n  const editionPDA = await Edition.getPDA(mint.publicKey);\n\n  const newEditionFromMasterTx = new MintNewEditionFromMasterEditionViaToken(\n    { feePayer: wallet.publicKey },\n    {\n      edition: editionPDA, //empty, created inside program\n      metadata: metadataPDA, //empty, created inside program\n      updateAuthority: updateAuthority ?? wallet.publicKey,\n      mint: mint.publicKey,\n      mintAuthority: wallet.publicKey,\n      masterEdition: masterPDA,\n      masterMetadata: masterMetaPDA,\n      editionMarker, // empty if this is the 1st limited edition being created\n      tokenOwner: wallet.publicKey,\n      tokenAccount,\n      editionValue,\n    },\n  );\n\n  const txId = await sendTransaction({\n    connection,\n    signers: [mint],\n    txs: [createMintTx, createAssociatedTokenAccountTx, mintToTx, newEditionFromMasterTx],\n    wallet,\n  });\n\n  return {\n    txId,\n    mint: mint.publicKey,\n    metadata: metadataPDA,\n    edition: editionPDA,\n  };\n};\n","import { Keypair } from '@solana/web3.js';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ninterface TransactionsBatchParams {\n  beforeTransactions?: Transaction[];\n  transactions: Transaction[];\n  afterTransactions?: Transaction[];\n}\n\nexport class TransactionsBatch {\n  beforeTransactions: Transaction[];\n  transactions: Transaction[];\n  afterTransactions: Transaction[];\n\n  signers: Keypair[] = [];\n\n  constructor({\n    beforeTransactions = [],\n    transactions,\n    afterTransactions = [],\n  }: TransactionsBatchParams) {\n    this.beforeTransactions = beforeTransactions;\n    this.transactions = transactions;\n    this.afterTransactions = afterTransactions;\n  }\n\n  addSigner(signer: Keypair) {\n    this.signers.push(signer);\n  }\n\n  addBeforeTransaction(transaction: Transaction) {\n    this.beforeTransactions.push(transaction);\n  }\n\n  addTransaction(transaction: Transaction) {\n    this.transactions.push(transaction);\n  }\n\n  addAfterTransaction(transaction: Transaction) {\n    this.afterTransactions.push(transaction);\n  }\n\n  toTransactions() {\n    return [...this.beforeTransactions, ...this.transactions, ...this.afterTransactions];\n  }\n\n  toInstructions() {\n    return this.toTransactions().flatMap((t) => t.instructions);\n  }\n}\n","import { Connection } from '../Connection';\nimport { Wallet } from '../wallet';\n\nimport { ActivateVault, CombineVault, Vault } from '@metaplex-foundation/mpl-token-vault';\nimport { Keypair, PublicKey, TransactionSignature } from '@solana/web3.js';\nimport { AccountLayout, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { CreateTokenAccount } from '../programs';\nimport { sendTransaction } from '../actions/transactions';\nimport BN from 'bn.js';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ninterface CloseVaultParams {\n  connection: Connection;\n  wallet: Wallet;\n  vault: PublicKey;\n  priceMint: PublicKey;\n}\n\ninterface CloseVaultResponse {\n  txId: TransactionSignature;\n}\n\n// This command \"closes\" the vault, by activating & combining it in one go, handing it over to the auction manager\n// authority (that may or may not exist yet.)\nexport const closeVault = async ({\n  connection,\n  wallet,\n  vault,\n  priceMint,\n}: CloseVaultParams): Promise<CloseVaultResponse> => {\n  const accountRent = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n  const fractionMintAuthority = await Vault.getPDA(vault);\n\n  const txBatch = new TransactionsBatch({ transactions: [] });\n\n  const txOptions = { feePayer: wallet.publicKey };\n\n  const {\n    data: { fractionMint, fractionTreasury, redeemTreasury, pricingLookupAddress },\n  } = await Vault.load(connection, vault);\n\n  const fractionMintKey = new PublicKey(fractionMint);\n  const fractionTreasuryKey = new PublicKey(fractionTreasury);\n  const redeemTreasuryKey = new PublicKey(redeemTreasury);\n  const pricingLookupAddressKey = new PublicKey(pricingLookupAddress);\n\n  const activateVaultTx = new ActivateVault(txOptions, {\n    vault,\n    numberOfShares: new BN(0),\n    fractionMint: fractionMintKey,\n    fractionTreasury: fractionTreasuryKey,\n    fractionMintAuthority,\n    vaultAuthority: wallet.publicKey,\n  });\n  txBatch.addTransaction(activateVaultTx);\n\n  const outstandingShareAccount = Keypair.generate();\n  const outstandingShareAccountTx = new CreateTokenAccount(txOptions, {\n    newAccountPubkey: outstandingShareAccount.publicKey,\n    lamports: accountRent,\n    mint: fractionMintKey,\n    owner: wallet.publicKey,\n  });\n  txBatch.addTransaction(outstandingShareAccountTx);\n  txBatch.addSigner(outstandingShareAccount);\n\n  const payingTokenAccount = Keypair.generate();\n  const payingTokenAccountTx = new CreateTokenAccount(txOptions, {\n    newAccountPubkey: payingTokenAccount.publicKey,\n    lamports: accountRent,\n    mint: priceMint,\n    owner: wallet.publicKey,\n  });\n  txBatch.addTransaction(payingTokenAccountTx);\n  txBatch.addSigner(payingTokenAccount);\n\n  const transferAuthority = Keypair.generate();\n\n  const createApproveTx = (account: Keypair) =>\n    new Transaction().add(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        account.publicKey,\n        transferAuthority.publicKey,\n        wallet.publicKey,\n        [],\n        0,\n      ),\n    );\n\n  txBatch.addTransaction(createApproveTx(payingTokenAccount));\n  txBatch.addTransaction(createApproveTx(outstandingShareAccount));\n  txBatch.addSigner(transferAuthority);\n\n  const combineVaultTx = new CombineVault(txOptions, {\n    vault,\n    outstandingShareTokenAccount: outstandingShareAccount.publicKey,\n    payingTokenAccount: payingTokenAccount.publicKey,\n    fractionMint: fractionMintKey,\n    fractionTreasury: fractionTreasuryKey,\n    redeemTreasury: redeemTreasuryKey,\n    burnAuthority: fractionMintAuthority,\n    externalPriceAccount: pricingLookupAddressKey,\n    transferAuthority: transferAuthority.publicKey,\n    vaultAuthority: wallet.publicKey,\n    newVaultAuthority: wallet.publicKey,\n  });\n  txBatch.addTransaction(combineVaultTx);\n\n  const txId = await sendTransaction({\n    connection,\n    signers: txBatch.signers,\n    txs: txBatch.transactions,\n    wallet,\n  });\n\n  return {\n    txId,\n  };\n};\n","import { Connection } from '../Connection';\nimport { Wallet } from '../wallet';\n\nimport { Transaction } from '@metaplex-foundation/mpl-core';\nimport { InitVault, Vault, VaultProgram } from '@metaplex-foundation/mpl-token-vault';\nimport { Keypair, PublicKey, SystemProgram, TransactionSignature } from '@solana/web3.js';\nimport { AccountLayout, MintLayout, NATIVE_MINT } from '@solana/spl-token';\nimport { CreateMint, CreateTokenAccount } from '../programs';\nimport { sendTransaction } from '../actions/transactions';\nimport { TransactionsBatch } from '../utils/transactions-batch';\n\ninterface CreateVaultParams {\n  connection: Connection;\n  wallet: Wallet;\n  priceMint: PublicKey;\n  externalPriceAccount: PublicKey;\n}\n\ninterface CreateVaultResponse {\n  txId: TransactionSignature;\n  vault: PublicKey;\n  fractionMint: PublicKey;\n  redeemTreasury: PublicKey;\n  fractionTreasury: PublicKey;\n}\n\n// This command creates the external pricing oracle a vault\n// This gets the vault ready for adding the tokens.\nexport const createVault = async ({\n  connection,\n  wallet,\n  priceMint = NATIVE_MINT,\n  externalPriceAccount,\n}: CreateVaultParams): Promise<CreateVaultResponse> => {\n  const accountRent = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n  const mintRent = await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n\n  const vaultRent = await connection.getMinimumBalanceForRentExemption(Vault.MAX_VAULT_SIZE);\n\n  const vault = Keypair.generate();\n\n  const vaultAuthority = await Vault.getPDA(vault.publicKey);\n\n  const txBatch = new TransactionsBatch({ transactions: [] });\n\n  const fractionMint = Keypair.generate();\n  const fractionMintTx = new CreateMint(\n    { feePayer: wallet.publicKey },\n    {\n      newAccountPubkey: fractionMint.publicKey,\n      lamports: mintRent,\n      owner: vaultAuthority,\n      freezeAuthority: vaultAuthority,\n    },\n  );\n  txBatch.addTransaction(fractionMintTx);\n  txBatch.addSigner(fractionMint);\n\n  const redeemTreasury = Keypair.generate();\n  const redeemTreasuryTx = new CreateTokenAccount(\n    { feePayer: wallet.publicKey },\n    {\n      newAccountPubkey: redeemTreasury.publicKey,\n      lamports: accountRent,\n      mint: priceMint,\n      owner: vaultAuthority,\n    },\n  );\n  txBatch.addTransaction(redeemTreasuryTx);\n  txBatch.addSigner(redeemTreasury);\n\n  const fractionTreasury = Keypair.generate();\n  const fractionTreasuryTx = new CreateTokenAccount(\n    { feePayer: wallet.publicKey },\n    {\n      newAccountPubkey: fractionTreasury.publicKey,\n      lamports: accountRent,\n      mint: fractionMint.publicKey,\n      owner: vaultAuthority,\n    },\n  );\n  txBatch.addTransaction(fractionTreasuryTx);\n  txBatch.addSigner(fractionTreasury);\n\n  const uninitializedVaultTx = new Transaction().add(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: vault.publicKey,\n      lamports: vaultRent,\n      space: Vault.MAX_VAULT_SIZE,\n      programId: VaultProgram.PUBKEY,\n    }),\n  );\n  txBatch.addTransaction(uninitializedVaultTx);\n  txBatch.addSigner(vault);\n\n  const initVaultTx = new InitVault(\n    { feePayer: wallet.publicKey },\n    {\n      vault: vault.publicKey,\n      vaultAuthority: wallet.publicKey,\n      fractionalTreasury: fractionTreasury.publicKey,\n      pricingLookupAddress: externalPriceAccount,\n      redeemTreasury: redeemTreasury.publicKey,\n      fractionalMint: fractionMint.publicKey,\n      allowFurtherShareCreation: true,\n    },\n  );\n  txBatch.addTransaction(initVaultTx);\n\n  const txId = await sendTransaction({\n    connection,\n    signers: txBatch.signers,\n    txs: txBatch.transactions,\n    wallet,\n  });\n\n  return {\n    txId,\n    vault: vault.publicKey,\n    fractionMint: fractionMint.publicKey,\n    redeemTreasury: redeemTreasury.publicKey,\n    fractionTreasury: fractionTreasury.publicKey,\n  };\n};\n","import { Connection } from '../Connection';\nimport { Wallet } from '../wallet';\n\nimport {\n  ExternalPriceAccountData,\n  Vault,\n  VaultProgram,\n  UpdateExternalPriceAccount,\n} from '@metaplex-foundation/mpl-token-vault';\nimport {\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionCtorFields,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { NATIVE_MINT } from '@solana/spl-token';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\nimport { sendTransaction } from '../actions/transactions';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport BN from 'bn.js';\n\ninterface CreateExternalPriceAccountParams {\n  connection: Connection;\n  wallet: Wallet;\n}\n\ninterface CreateExternalPriceAccountResponse {\n  txId: TransactionSignature;\n  externalPriceAccount: PublicKey;\n  priceMint: PublicKey;\n}\n\n// This command creates the external pricing oracle\nexport const createExternalPriceAccount = async ({\n  connection,\n  wallet,\n}: CreateExternalPriceAccountParams): Promise<CreateExternalPriceAccountResponse> => {\n  const txBatch = new TransactionsBatch({ transactions: [] });\n  const txOptions: TransactionCtorFields = { feePayer: wallet.publicKey };\n\n  const epaRentExempt = await connection.getMinimumBalanceForRentExemption(\n    Vault.MAX_EXTERNAL_ACCOUNT_SIZE,\n  );\n\n  const externalPriceAccount = Keypair.generate();\n\n  const externalPriceAccountData = new ExternalPriceAccountData({\n    pricePerShare: new BN(0),\n    priceMint: NATIVE_MINT.toBase58(),\n    allowedToCombine: true,\n  });\n\n  const uninitializedEPA = new Transaction().add(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: externalPriceAccount.publicKey,\n      lamports: epaRentExempt,\n      space: Vault.MAX_EXTERNAL_ACCOUNT_SIZE,\n      programId: VaultProgram.PUBKEY,\n    }),\n  );\n  txBatch.addTransaction(uninitializedEPA);\n  txBatch.addSigner(externalPriceAccount);\n\n  const updateEPA = new UpdateExternalPriceAccount(txOptions, {\n    externalPriceAccount: externalPriceAccount.publicKey,\n    externalPriceAccountData,\n  });\n  txBatch.addTransaction(updateEPA);\n\n  const txId = await sendTransaction({\n    connection,\n    signers: txBatch.signers,\n    txs: txBatch.transactions,\n    wallet,\n  });\n\n  return {\n    txId,\n    externalPriceAccount: externalPriceAccount.publicKey,\n    priceMint: NATIVE_MINT,\n  };\n};\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport {\n  CreateMetadata,\n  Metadata,\n  MetadataDataData,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { sendTransaction } from './transactions';\n\ninterface CreateMetadataParams {\n  connection: Connection;\n  wallet: Wallet;\n  editionMint: PublicKey; // can be any mint with 0 decimals\n  metadataData: MetadataDataData;\n  updateAuthority?: PublicKey;\n}\n\nexport const createMetadata = async (\n  { connection, wallet, editionMint, metadataData, updateAuthority } = {} as CreateMetadataParams,\n): Promise<string> => {\n  const metadata = await Metadata.getPDA(editionMint);\n\n  const createMetadataTx = new CreateMetadata(\n    { feePayer: wallet.publicKey },\n    {\n      metadata,\n      metadataData,\n      updateAuthority: updateAuthority ?? wallet.publicKey,\n      mint: editionMint,\n      mintAuthority: wallet.publicKey,\n    },\n  );\n  return sendTransaction({\n    connection,\n    signers: [],\n    txs: [createMetadataTx],\n    wallet,\n  });\n};\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport {\n  CreateMasterEdition,\n  MasterEdition,\n  Metadata,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { sendTransaction } from './transactions';\nimport BN from 'bn.js';\n\ninterface CreateMasterEditionParams {\n  connection: Connection;\n  wallet: Wallet;\n  editionMint: PublicKey;\n  updateAuthority?: PublicKey;\n  maxSupply?: BN;\n}\n\n/*\n * NOTE 1: a metadata account must already exist\n * NOTE 2: must have exactly 1 editionMint token with 0 decimals outstanding\n */\nexport const createMasterEdition = async (\n  { connection, wallet, editionMint, updateAuthority, maxSupply } = {} as CreateMasterEditionParams,\n): Promise<string> => {\n  const metadata = await Metadata.getPDA(editionMint);\n  const edition = await MasterEdition.getPDA(editionMint);\n\n  const createMetadataTx = new CreateMasterEdition(\n    { feePayer: wallet.publicKey },\n    {\n      edition,\n      metadata,\n      updateAuthority: updateAuthority ?? wallet.publicKey,\n      mint: editionMint,\n      mintAuthority: wallet.publicKey,\n      maxSupply,\n    },\n  );\n  return sendTransaction({\n    connection,\n    signers: [],\n    txs: [createMetadataTx],\n    wallet,\n  });\n};\n","import { Connection, Keypair, PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Metadata, SignMetadata } from '@metaplex-foundation/mpl-token-metadata';\nimport { sendTransaction } from './transactions';\n\ninterface SignMetadataParams {\n  connection: Connection;\n  wallet: Wallet;\n  editionMint: PublicKey;\n  signer?: Keypair;\n}\n\nexport const signMetadata = async (\n  { connection, wallet, editionMint, signer } = {} as SignMetadataParams,\n): Promise<string> => {\n  const metadata = await Metadata.getPDA(editionMint);\n  const signTx = new SignMetadata(\n    { feePayer: wallet.publicKey },\n    {\n      metadata,\n      creator: signer ? signer.publicKey : wallet.publicKey,\n    },\n  );\n  return await sendTransaction({\n    connection,\n    signers: signer ? [signer] : [],\n    txs: [signTx],\n    wallet,\n  });\n};\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport {\n  Metadata,\n  MetadataDataData,\n  UpdateMetadata,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { sendTransaction } from './transactions';\n\ninterface UpdateMetadataParams {\n  connection: Connection;\n  wallet: Wallet;\n  editionMint: PublicKey;\n  newMetadataData?: MetadataDataData;\n  newUpdateAuthority?: PublicKey;\n  primarySaleHappened?: boolean;\n}\n\n/*\n * Can be used to update any of the below 3:\n * 1) data inside metadata, but only if it's mutable (which is only possible for MasterEditions)\n * 2) updateAuthority\n * 3) whether primary sale has happened (can only be set true, never back false)\n */\nexport const updateMetadata = async (\n  {\n    connection,\n    wallet,\n    editionMint,\n    newMetadataData,\n    newUpdateAuthority,\n    primarySaleHappened,\n  } = {} as UpdateMetadataParams,\n): Promise<string> => {\n  const metadata = await Metadata.getPDA(editionMint);\n  const updateTx = new UpdateMetadata(\n    { feePayer: wallet.publicKey },\n    {\n      metadata,\n      updateAuthority: wallet.publicKey,\n      metadataData: newMetadataData,\n      newUpdateAuthority,\n      primarySaleHappened,\n    },\n  );\n  return sendTransaction({\n    connection,\n    signers: [],\n    txs: [updateTx],\n    wallet,\n  });\n};\n","import { Keypair, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, NATIVE_MINT, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport {\n  AuctionExtended,\n  BidderMetadata,\n  BidderPot,\n  CancelBid,\n} from '@metaplex-foundation/mpl-auction';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport { AuctionManager } from '@metaplex-foundation/mpl-metaplex';\nimport { CreateTokenAccount } from '../programs';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\n\ninterface ICancelBidParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  bidderPotToken: PublicKey;\n  destAccount?: PublicKey;\n}\n\ninterface ICancelBidResponse {\n  txId: string;\n}\n\nexport const cancelBid = async ({\n  connection,\n  wallet,\n  auction,\n  bidderPotToken,\n  destAccount,\n}: ICancelBidParams): Promise<ICancelBidResponse> => {\n  const bidder = wallet.publicKey;\n  const auctionManager = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManager);\n  const {\n    data: { tokenMint },\n  } = await manager.getAuction(connection);\n\n  const auctionTokenMint = new PublicKey(tokenMint);\n  const vault = new PublicKey(manager.data.vault);\n  const auctionExtended = await AuctionExtended.getPDA(vault);\n  const bidderPot = await BidderPot.getPDA(auction, bidder);\n  const bidderMeta = await BidderMetadata.getPDA(auction, bidder);\n\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const txBatch = await getCancelBidTransactions({\n    destAccount,\n    bidder,\n    accountRentExempt,\n    bidderPot,\n    bidderPotToken,\n    bidderMeta,\n    auction,\n    auctionExtended,\n    auctionTokenMint,\n    vault,\n  });\n\n  const txId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txBatch.toTransactions(),\n    signers: txBatch.signers,\n  });\n\n  return { txId };\n};\n\ninterface ICancelBidTransactionsParams {\n  destAccount?: PublicKey;\n  bidder: PublicKey;\n  accountRentExempt: number;\n  bidderPot: PublicKey;\n  bidderPotToken: PublicKey;\n  bidderMeta: PublicKey;\n  auction: PublicKey;\n  auctionExtended: PublicKey;\n  auctionTokenMint: PublicKey;\n  vault: PublicKey;\n}\n\nexport const getCancelBidTransactions = async ({\n  destAccount,\n  bidder,\n  accountRentExempt,\n  bidderPot,\n  bidderPotToken,\n  bidderMeta,\n  auction,\n  auctionExtended,\n  auctionTokenMint,\n  vault,\n}: ICancelBidTransactionsParams): Promise<TransactionsBatch> => {\n  const txBatch = new TransactionsBatch({ transactions: [] });\n  if (!destAccount) {\n    const account = Keypair.generate();\n    const createTokenAccountTransaction = new CreateTokenAccount(\n      { feePayer: bidder },\n      {\n        newAccountPubkey: account.publicKey,\n        lamports: accountRentExempt,\n        mint: NATIVE_MINT,\n      },\n    );\n    const closeTokenAccountInstruction = new Transaction().add(\n      Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, bidder, bidder, []),\n    );\n    txBatch.addTransaction(createTokenAccountTransaction);\n    txBatch.addAfterTransaction(closeTokenAccountInstruction);\n    txBatch.addSigner(account);\n    destAccount = account.publicKey;\n  }\n\n  const cancelBidTransaction = new CancelBid(\n    { feePayer: bidder },\n    {\n      bidder,\n      bidderToken: destAccount,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      tokenMint: auctionTokenMint,\n      resource: vault,\n    },\n  );\n  txBatch.addTransaction(cancelBidTransaction);\n\n  return txBatch;\n};\n","import BN from 'bn.js';\nimport { Commitment, Keypair, PublicKey, TransactionSignature } from '@solana/web3.js';\nimport { AccountLayout } from '@solana/spl-token';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport {\n  AuctionExtended,\n  BidderMetadata,\n  BidderPot,\n  PlaceBid,\n} from '@metaplex-foundation/mpl-auction';\nimport { AuctionManager } from '@metaplex-foundation/mpl-metaplex';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport { getCancelBidTransactions } from './cancelBid';\nimport { CreateTokenAccount } from '../programs';\nimport { createApproveTxs, createWrappedAccountTxs } from './shared';\n\ninterface IPlaceBidParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  bidderPotToken?: PublicKey;\n  // amount in lamports\n  amount: BN;\n  commitment?: Commitment;\n}\n\ninterface IPlaceBidResponse {\n  txId: TransactionSignature;\n  bidderPotToken: PublicKey;\n  bidderMeta: PublicKey;\n}\n\nexport const placeBid = async ({\n  connection,\n  wallet,\n  amount,\n  auction,\n  bidderPotToken,\n}: IPlaceBidParams): Promise<IPlaceBidResponse> => {\n  // get data for transactions\n  const bidder = wallet.publicKey;\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const auctionManager = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManager);\n  const {\n    data: { tokenMint },\n  } = await manager.getAuction(connection);\n  const auctionTokenMint = new PublicKey(tokenMint);\n  const vault = new PublicKey(manager.data.vault);\n  const auctionExtended = await AuctionExtended.getPDA(vault);\n  const bidderPot = await BidderPot.getPDA(auction, bidder);\n  const bidderMeta = await BidderMetadata.getPDA(auction, bidder);\n  ////\n\n  let txBatch = new TransactionsBatch({ transactions: [] });\n\n  if (bidderPotToken) {\n    // cancel prev bid\n    txBatch = await getCancelBidTransactions({\n      destAccount: null,\n      bidder,\n      accountRentExempt,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      auctionTokenMint,\n      vault,\n    });\n    ////\n  } else {\n    // create a new account for bid\n    const account = Keypair.generate();\n    const createBidderPotTransaction = new CreateTokenAccount(\n      { feePayer: bidder },\n      {\n        newAccountPubkey: account.publicKey,\n        lamports: accountRentExempt,\n        mint: auctionTokenMint,\n        owner: auction,\n      },\n    );\n    txBatch.addSigner(account);\n    txBatch.addTransaction(createBidderPotTransaction);\n    bidderPotToken = account.publicKey;\n    ////\n  }\n\n  // create paying account\n  const {\n    account: payingAccount,\n    createTokenAccountTx,\n    closeTokenAccountTx,\n  } = await createWrappedAccountTxs(connection, bidder, amount.toNumber() + accountRentExempt * 2);\n  txBatch.addTransaction(createTokenAccountTx);\n  txBatch.addAfterTransaction(closeTokenAccountTx);\n  txBatch.addSigner(payingAccount);\n  ////\n\n  // transfer authority\n  const {\n    authority: transferAuthority,\n    createApproveTx,\n    createRevokeTx,\n  } = createApproveTxs({\n    account: payingAccount.publicKey,\n    owner: bidder,\n    amount: amount.toNumber(),\n  });\n  txBatch.addTransaction(createApproveTx);\n  txBatch.addAfterTransaction(createRevokeTx);\n  txBatch.addSigner(transferAuthority);\n  ////\n\n  // create place bid transaction\n  const placeBidTransaction = new PlaceBid(\n    { feePayer: bidder },\n    {\n      bidder,\n      bidderToken: payingAccount.publicKey,\n      bidderPot,\n      bidderPotToken,\n      bidderMeta,\n      auction,\n      auctionExtended,\n      tokenMint: auctionTokenMint,\n      transferAuthority: transferAuthority.publicKey,\n      amount,\n      resource: vault,\n    },\n  );\n  txBatch.addTransaction(placeBidTransaction);\n  ////\n\n  const txId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txBatch.toTransactions(),\n    signers: txBatch.signers,\n  });\n\n  return { txId, bidderPotToken, bidderMeta };\n};\n","import { Keypair, PublicKey } from '@solana/web3.js';\nimport { AccountLayout } from '@solana/spl-token';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { AuctionExtended, BidderMetadata } from '@metaplex-foundation/mpl-auction';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport {\n  AuctionManager,\n  MetaplexProgram,\n  RedeemFullRightsTransferBid,\n  SafetyDepositConfig,\n} from '@metaplex-foundation/mpl-metaplex';\nimport { CreateTokenAccount } from '../programs';\nimport { Vault } from '@metaplex-foundation/mpl-token-vault';\nimport {\n  Metadata,\n  UpdatePrimarySaleHappenedViaToken,\n} from '@metaplex-foundation/mpl-token-metadata';\n\ninterface IRedeemBidParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  store: PublicKey;\n}\n\ninterface IRedeemBidResponse {\n  txId: string;\n}\n\nexport const redeemFullRightsTransferBid = async ({\n  connection,\n  wallet,\n  store,\n  auction,\n}: IRedeemBidParams): Promise<IRedeemBidResponse> => {\n  // get data for transactions\n  const bidder = wallet.publicKey;\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const auctionManager = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManager);\n  const vault = await Vault.load(connection, manager.data.vault);\n  const fractionMint = new PublicKey(vault.data.fractionMint);\n  const auctionExtended = await AuctionExtended.getPDA(vault.pubkey);\n  // assuming we have 1 item\n  const [safetyDepositBox] = await vault.getSafetyDepositBoxes(connection);\n  const tokenMint = new PublicKey(safetyDepositBox.data.tokenMint);\n  const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n  const bidderMeta = await BidderMetadata.getPDA(auction, bidder);\n  const bidRedemption = await getBidRedemptionPDA(auction, bidderMeta);\n  const safetyDepositConfig = await SafetyDepositConfig.getPDA(\n    auctionManager,\n    safetyDepositBox.pubkey,\n  );\n  const transferAuthority = await Vault.getPDA(vault.pubkey);\n  const metadata = await Metadata.getPDA(tokenMint);\n  ////\n\n  const txBatch = await getRedeemFRTBidTransactions({\n    accountRentExempt,\n    tokenMint,\n    bidder,\n    bidderMeta,\n    store,\n    vault: vault.pubkey,\n    auction,\n    auctionExtended,\n    auctionManager,\n    fractionMint,\n    safetyDepositTokenStore,\n    safetyDeposit: safetyDepositBox.pubkey,\n    bidRedemption,\n    safetyDepositConfig,\n    transferAuthority,\n    metadata,\n  });\n\n  const txId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txBatch.toTransactions(),\n    signers: txBatch.signers,\n  });\n\n  return { txId };\n};\n\ninterface IRedeemBidTransactionsParams {\n  bidder: PublicKey;\n  accountRentExempt: number;\n  bidderPotToken?: PublicKey;\n  bidderMeta: PublicKey;\n  auction: PublicKey;\n  auctionExtended: PublicKey;\n  tokenMint: PublicKey;\n  vault: PublicKey;\n  store: PublicKey;\n  auctionManager: PublicKey;\n  bidRedemption: PublicKey;\n  safetyDepositTokenStore: PublicKey;\n  safetyDeposit: PublicKey;\n  fractionMint: PublicKey;\n  safetyDepositConfig: PublicKey;\n  transferAuthority: PublicKey;\n  metadata: PublicKey;\n}\n\nexport const getRedeemFRTBidTransactions = async ({\n  accountRentExempt,\n  bidder,\n  tokenMint,\n  store,\n  vault,\n  auction,\n  auctionManager,\n  auctionExtended,\n  bidRedemption,\n  bidderMeta: bidMetadata,\n  safetyDepositTokenStore,\n  safetyDeposit,\n  fractionMint,\n  safetyDepositConfig,\n  transferAuthority,\n  metadata,\n}: IRedeemBidTransactionsParams) => {\n  const txBatch = new TransactionsBatch({ transactions: [] });\n\n  // create a new account for redeeming\n  const account = Keypair.generate();\n  const createDestinationTransaction = new CreateTokenAccount(\n    { feePayer: bidder },\n    {\n      newAccountPubkey: account.publicKey,\n      lamports: accountRentExempt,\n      mint: tokenMint,\n    },\n  );\n  txBatch.addSigner(account);\n  txBatch.addTransaction(createDestinationTransaction);\n  ////\n\n  // create redeem bid\n  const redeemBidTransaction = new RedeemFullRightsTransferBid(\n    { feePayer: bidder },\n    {\n      store,\n      vault,\n      auction,\n      auctionManager,\n      bidRedemption,\n      bidMetadata,\n      safetyDepositTokenStore,\n      destination: account.publicKey,\n      safetyDeposit,\n      fractionMint,\n      bidder,\n      safetyDepositConfig,\n      auctionExtended,\n      transferAuthority,\n      newAuthority: bidder,\n      masterMetadata: metadata,\n    },\n  );\n  txBatch.addTransaction(redeemBidTransaction);\n  ////\n\n  // update primary sale happened via token\n  const updatePrimarySaleHappenedViaTokenTransaction = new UpdatePrimarySaleHappenedViaToken(\n    { feePayer: bidder },\n    {\n      metadata,\n      owner: bidder,\n      tokenAccount: account.publicKey,\n    },\n  );\n  txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTransaction);\n  ////\n\n  return txBatch;\n};\n\nexport const getBidRedemptionPDA = async (auction: PublicKey, bidderMeta: PublicKey) => {\n  return (\n    await PublicKey.findProgramAddress(\n      [Buffer.from(MetaplexProgram.PREFIX), auction.toBuffer(), bidderMeta.toBuffer()],\n      MetaplexProgram.PUBKEY,\n    )\n  )[0];\n};\n","import BN from 'bn.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { Auction, AuctionExtended, BidderMetadata } from '@metaplex-foundation/mpl-auction';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport {\n  AuctionManager,\n  PrizeTrackingTicket,\n  SafetyDepositConfig,\n} from '@metaplex-foundation/mpl-metaplex';\nimport { Vault } from '@metaplex-foundation/mpl-token-vault';\nimport {\n  Edition,\n  EditionMarker,\n  MasterEdition,\n  Metadata,\n  UpdatePrimarySaleHappenedViaToken,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { RedeemPrintingV2Bid } from '@metaplex-foundation/mpl-metaplex';\nimport { prepareTokenAccountAndMintTxs } from './shared';\nimport { getBidRedemptionPDA } from './redeemFullRightsTransferBid';\n\ninterface IRedeemBidParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  store: PublicKey;\n}\n\ninterface IRedeemBidResponse {\n  txId: string;\n}\n\ninterface IRedeemBidTransactionsParams {\n  bidder: PublicKey;\n  bidderPotToken?: PublicKey;\n  bidderMeta: PublicKey;\n  auction: PublicKey;\n  auctionExtended: PublicKey;\n  destination: PublicKey;\n  vault: PublicKey;\n  store: PublicKey;\n  auctionManager: PublicKey;\n  bidRedemption: PublicKey;\n  safetyDepositTokenStore: PublicKey;\n  safetyDeposit: PublicKey;\n  safetyDepositConfig: PublicKey;\n  metadata: PublicKey;\n  newMint: PublicKey;\n  newMetadata: PublicKey;\n  newEdition: PublicKey;\n  masterEdition: PublicKey;\n  editionMarker: PublicKey;\n  prizeTrackingTicket: PublicKey;\n  winIndex: BN;\n  editionOffset: BN;\n}\n\nexport const redeemPrintingV2Bid = async ({\n  connection,\n  wallet,\n  store,\n  auction,\n}: IRedeemBidParams): Promise<IRedeemBidResponse> => {\n  const bidder = wallet.publicKey;\n  const {\n    data: { bidState },\n  } = await Auction.load(connection, auction);\n  const auctionManagerPDA = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManagerPDA);\n  const vault = await Vault.load(connection, manager.data.vault);\n  const auctionExtendedPDA = await AuctionExtended.getPDA(vault.pubkey);\n  const [safetyDepositBox] = await vault.getSafetyDepositBoxes(connection);\n  const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n\n  const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n  const bidderMetaPDA = await BidderMetadata.getPDA(auction, bidder);\n  const bidRedemptionPDA = await getBidRedemptionPDA(auction, bidderMetaPDA);\n  const safetyDepositConfigPDA = await SafetyDepositConfig.getPDA(\n    auctionManagerPDA,\n    safetyDepositBox.pubkey,\n  );\n\n  const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient } =\n    await prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n  const newMint = mint.publicKey;\n  const newMetadataPDA = await Metadata.getPDA(newMint);\n  const newEditionPDA = await Edition.getPDA(newMint);\n\n  const metadataPDA = await Metadata.getPDA(originalMint);\n  const masterEditionPDA = await MasterEdition.getPDA(originalMint);\n  const masterEdition = await MasterEdition.load(connection, masterEditionPDA);\n\n  const prizeTrackingTicketPDA = await PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n\n  let prizeTrackingTicket: PrizeTrackingTicket;\n  // this account doesn't exist when we do redeem for the first time\n  try {\n    prizeTrackingTicket = await PrizeTrackingTicket.load(connection, prizeTrackingTicketPDA);\n  } catch (e) {\n    prizeTrackingTicket = null;\n  }\n\n  const winIndex = bidState.getWinnerIndex(bidder.toBase58()) || 0;\n\n  const editionOffset = getEditionOffset(winIndex);\n  const editionBase = prizeTrackingTicket?.data.supplySnapshot || masterEdition.data.supply;\n  const desiredEdition = editionBase.add(editionOffset);\n  const editionMarkerPDA = await EditionMarker.getPDA(originalMint, desiredEdition);\n\n  // checking if edition marker is taken\n  try {\n    const editionMarker = await EditionMarker.load(connection, editionMarkerPDA);\n    const isEditionTaken = editionMarker.data.editionTaken(desiredEdition.toNumber());\n    if (isEditionTaken) {\n      throw new Error('The edition is already taken');\n    }\n  } catch (e) {\n    // it's not. continue\n  }\n\n  const txBatch = await getRedeemPrintingV2BidTransactions({\n    bidder,\n    bidderMeta: bidderMetaPDA,\n    store,\n    vault: vault.pubkey,\n    destination: recipient,\n    auction,\n    auctionExtended: auctionExtendedPDA,\n    auctionManager: auctionManagerPDA,\n    safetyDepositTokenStore,\n    safetyDeposit: safetyDepositBox.pubkey,\n    bidRedemption: bidRedemptionPDA,\n    safetyDepositConfig: safetyDepositConfigPDA,\n\n    metadata: metadataPDA,\n    newMint,\n    newMetadata: newMetadataPDA,\n    newEdition: newEditionPDA,\n    masterEdition: masterEditionPDA,\n    editionMarker: editionMarkerPDA,\n    prizeTrackingTicket: prizeTrackingTicketPDA,\n    editionOffset,\n    winIndex: new BN(winIndex),\n  });\n\n  txBatch.addSigner(mint);\n  txBatch.addBeforeTransaction(createMintTx);\n  txBatch.addBeforeTransaction(createAssociatedTokenAccountTx);\n  txBatch.addBeforeTransaction(mintToTx);\n\n  const txId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txBatch.toTransactions(),\n    signers: txBatch.signers,\n  });\n\n  return { txId };\n};\n\nexport const getRedeemPrintingV2BidTransactions = async ({\n  bidder,\n  destination,\n  store,\n  vault,\n  auction,\n  auctionManager,\n  auctionExtended,\n  bidRedemption,\n  bidderMeta: bidMetadata,\n  safetyDepositTokenStore,\n  safetyDeposit,\n  safetyDepositConfig,\n\n  metadata,\n  newMint,\n  newMetadata,\n  newEdition,\n  masterEdition,\n  editionMarker: editionMark,\n  prizeTrackingTicket,\n\n  winIndex,\n  editionOffset,\n}: IRedeemBidTransactionsParams) => {\n  const txBatch = new TransactionsBatch({ transactions: [] });\n\n  const redeemPrintingV2BidTx = new RedeemPrintingV2Bid(\n    { feePayer: bidder },\n    {\n      store,\n      vault,\n      auction,\n      auctionManager,\n      bidRedemption,\n      bidMetadata,\n      safetyDepositTokenStore,\n      destination,\n      safetyDeposit,\n      bidder,\n      safetyDepositConfig,\n      auctionExtended,\n\n      newMint,\n      newEdition,\n      newMetadata,\n      metadata,\n      masterEdition,\n      editionMark,\n      prizeTrackingTicket,\n      winIndex,\n      editionOffset,\n    },\n  );\n  txBatch.addTransaction(redeemPrintingV2BidTx);\n\n  const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken(\n    { feePayer: bidder },\n    {\n      metadata: newMetadata,\n      owner: bidder,\n      tokenAccount: destination,\n    },\n  );\n  txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n\n  return txBatch;\n};\n\nexport function getEditionOffset(winIndex: number) {\n  const offset = new BN(1);\n  // NOTE: not sure if this the right way to calculate it\n  return offset.add(new BN(winIndex));\n}\n","import BN from 'bn.js';\nimport { PublicKey, TransactionSignature } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport { createApproveTxs, createWrappedAccountTxs, prepareTokenAccountAndMintTxs } from './shared';\nimport { getBidRedemptionPDA } from './redeemFullRightsTransferBid';\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  NATIVE_MINT,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from '@solana/spl-token';\nimport { Auction, AuctionExtended, BidderMetadata } from '@metaplex-foundation/mpl-auction';\nimport { Vault } from '@metaplex-foundation/mpl-token-vault';\nimport {\n  AuctionManager,\n  NonWinningConstraint,\n  ParticipationConfigV2,\n  PrizeTrackingTicket,\n  RedeemParticipationBidV3,\n  SafetyDepositConfig,\n  WinningConstraint,\n} from '@metaplex-foundation/mpl-metaplex';\nimport {\n  Edition,\n  EditionMarker,\n  MasterEdition,\n  Metadata,\n  UpdatePrimarySaleHappenedViaToken,\n} from '@metaplex-foundation/mpl-token-metadata';\n\ninterface IRedeemParticipationBidV3Params {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  store: PublicKey;\n}\n\ninterface IRedeemParticipationBidV3Response {\n  txIds: TransactionSignature[];\n}\n\nexport const redeemParticipationBidV3 = async ({\n  connection,\n  wallet,\n  store,\n  auction,\n}: IRedeemParticipationBidV3Params): Promise<IRedeemParticipationBidV3Response> => {\n  const txInitBatch = new TransactionsBatch({ transactions: [] });\n  const txMainBatch = new TransactionsBatch({ transactions: [] });\n\n  const bidder = wallet.publicKey;\n  const {\n    data: { bidState, tokenMint: auctionTokenMint },\n  } = await Auction.load(connection, auction);\n  const auctionManagerPDA = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManagerPDA);\n  const vault = await Vault.load(connection, manager.data.vault);\n  const auctionExtendedPDA = await AuctionExtended.getPDA(vault.pubkey);\n  const [safetyDepositBox] = await vault.getSafetyDepositBoxes(connection);\n  const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n\n  const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n  const bidderMetaPDA = await BidderMetadata.getPDA(auction, bidder);\n  const bidRedemptionPDA = await getBidRedemptionPDA(auction, bidderMetaPDA);\n  const safetyDepositConfigPDA = await SafetyDepositConfig.getPDA(\n    auctionManagerPDA,\n    safetyDepositBox.pubkey,\n  );\n  const {\n    data: {\n      participationConfig: { fixedPrice },\n    },\n  } = await SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n  const acceptPaymentAccount = new PublicKey(manager.data.acceptPayment);\n\n  const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient } =\n    await prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n  txInitBatch.addSigner(mint);\n  txInitBatch.addTransaction(createMintTx);\n  txInitBatch.addTransaction(createAssociatedTokenAccountTx);\n  txInitBatch.addTransaction(mintToTx);\n\n  const newMint = mint.publicKey;\n  const newMetadataPDA = await Metadata.getPDA(newMint);\n  const newEditionPDA = await Edition.getPDA(newMint);\n\n  const metadataPDA = await Metadata.getPDA(originalMint);\n  const masterEditionPDA = await MasterEdition.getPDA(originalMint);\n  const masterEdition = await MasterEdition.load(connection, masterEditionPDA);\n\n  const prizeTrackingTicketPDA = await PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n  const winIndex = bidState.getWinnerIndex(bidder.toBase58());\n\n  const desiredEdition = masterEdition.data.supply.add(new BN(1));\n  const editionMarkerPDA = await EditionMarker.getPDA(originalMint, desiredEdition);\n\n  let tokenPaymentAccount: PublicKey;\n  if (auctionTokenMint === NATIVE_MINT.toBase58()) {\n    const { account, createTokenAccountTx, closeTokenAccountTx } = await createWrappedAccountTxs(\n      connection,\n      bidder,\n      fixedPrice.toNumber(),\n    );\n    tokenPaymentAccount = account.publicKey;\n    txInitBatch.addTransaction(createTokenAccountTx);\n    txInitBatch.addSigner(account);\n    txMainBatch.addAfterTransaction(closeTokenAccountTx);\n  } else {\n    // TODO: find out what will happen if currency is not WSOL\n    tokenPaymentAccount = await Token.getAssociatedTokenAddress(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      new PublicKey(auctionTokenMint),\n      bidder,\n    );\n  }\n\n  const { authority, createApproveTx, createRevokeTx } = createApproveTxs({\n    account: tokenPaymentAccount,\n    owner: bidder,\n    amount: fixedPrice.toNumber(),\n  });\n  txMainBatch.addTransaction(createApproveTx);\n  txMainBatch.addAfterTransaction(createRevokeTx);\n  txMainBatch.addSigner(authority);\n\n  const redeemParticipationBidV3Tx = new RedeemParticipationBidV3(\n    { feePayer: bidder },\n    {\n      store,\n      vault: vault.pubkey,\n      auction,\n      auctionManager: auctionManagerPDA,\n      bidRedemption: bidRedemptionPDA,\n      bidMetadata: bidderMetaPDA,\n      safetyDepositTokenStore,\n      destination: recipient,\n      safetyDeposit: safetyDepositBox.pubkey,\n      bidder,\n      safetyDepositConfig: safetyDepositConfigPDA,\n      auctionExtended: auctionExtendedPDA,\n      newMint,\n      newEdition: newEditionPDA,\n      newMetadata: newMetadataPDA,\n      metadata: metadataPDA,\n      masterEdition: masterEditionPDA,\n      editionMark: editionMarkerPDA,\n      prizeTrackingTicket: prizeTrackingTicketPDA,\n      winIndex: winIndex !== null ? new BN(winIndex) : null,\n      transferAuthority: authority.publicKey,\n      tokenPaymentAccount,\n      acceptPaymentAccount,\n    },\n  );\n  txMainBatch.addTransaction(redeemParticipationBidV3Tx);\n\n  const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken(\n    { feePayer: bidder },\n    {\n      metadata: newMetadataPDA,\n      owner: bidder,\n      tokenAccount: recipient,\n    },\n  );\n  txMainBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n\n  const initTxId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txInitBatch.toTransactions(),\n    signers: txInitBatch.signers,\n  });\n\n  // wait for all accounts to be created\n  await connection.confirmTransaction(initTxId, 'finalized');\n\n  const mainTxId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txMainBatch.toTransactions(),\n    signers: txMainBatch.signers,\n  });\n\n  return { txIds: [initTxId, mainTxId] };\n};\n\nexport function isEligibleForParticipationPrize(\n  winIndex: number,\n  { nonWinningConstraint, winnerConstraint }: ParticipationConfigV2 = {} as ParticipationConfigV2,\n) {\n  const noWinnerConstraints = winnerConstraint !== WinningConstraint.NoParticipationPrize;\n  const noNonWinnerConstraints = nonWinningConstraint !== NonWinningConstraint.NoParticipationPrize;\n  return (\n    (winIndex === null && noNonWinnerConstraints) || (winIndex !== null && noWinnerConstraints)\n  );\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { Auction, AuctionExtended, BidderPot } from '@metaplex-foundation/mpl-auction';\nimport { TransactionsBatch } from '../utils/transactions-batch';\nimport { AuctionManager, ClaimBid } from '@metaplex-foundation/mpl-metaplex';\n\ninterface IClaimBidParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  store: PublicKey;\n  bidderPotToken: PublicKey;\n}\n\ninterface IClaimBidResponse {\n  txId: string;\n}\n\nexport const claimBid = async ({\n  connection,\n  wallet,\n  store,\n  auction,\n  bidderPotToken,\n}: IClaimBidParams): Promise<IClaimBidResponse> => {\n  // get data for transactions\n  const bidder = wallet.publicKey;\n  const auctionManager = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManager);\n  const vault = new PublicKey(manager.data.vault);\n  const {\n    data: { tokenMint },\n  } = await Auction.load(connection, auction);\n  const acceptPayment = new PublicKey(manager.data.acceptPayment);\n  const auctionExtended = await AuctionExtended.getPDA(vault);\n  const auctionTokenMint = new PublicKey(tokenMint);\n  const bidderPot = await BidderPot.getPDA(auction, bidder);\n  ////\n\n  const txBatch = await getClaimBidTransactions({\n    auctionTokenMint,\n    bidder,\n    store,\n    vault,\n    auction,\n    auctionExtended,\n    auctionManager,\n    acceptPayment,\n    bidderPot,\n    bidderPotToken,\n  });\n\n  const txId = await sendTransaction({\n    connection,\n    wallet,\n    txs: txBatch.toTransactions(),\n    signers: txBatch.signers,\n  });\n\n  return { txId };\n};\n\ninterface IClaimBidTransactionsParams {\n  bidder: PublicKey;\n  bidderPotToken?: PublicKey;\n  bidderPot: PublicKey;\n  auction: PublicKey;\n  auctionExtended: PublicKey;\n  auctionTokenMint: PublicKey;\n  vault: PublicKey;\n  store: PublicKey;\n  auctionManager: PublicKey;\n  acceptPayment: PublicKey;\n}\n\nexport const getClaimBidTransactions = async ({\n  bidder,\n  auctionTokenMint,\n  store,\n  vault,\n  auction,\n  auctionManager,\n  auctionExtended,\n  acceptPayment,\n  bidderPot,\n  bidderPotToken,\n}: IClaimBidTransactionsParams) => {\n  const txBatch = new TransactionsBatch({ transactions: [] });\n\n  // create claim bid\n  const claimBidTransaction = new ClaimBid(\n    { feePayer: bidder },\n    {\n      store,\n      vault,\n      auction,\n      auctionExtended,\n      auctionManager,\n      bidder,\n      tokenMint: auctionTokenMint,\n      acceptPayment,\n      bidderPot,\n      bidderPotToken,\n    },\n  );\n  txBatch.addTransaction(claimBidTransaction);\n  ////\n\n  return txBatch;\n};\n","import { PublicKey, TransactionSignature } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { Auction, AuctionExtended } from '@metaplex-foundation/mpl-auction';\nimport {\n  AuctionManager,\n  SafetyDepositConfig,\n  WinningConfigType,\n} from '@metaplex-foundation/mpl-metaplex';\nimport { placeBid } from './placeBid';\nimport { claimBid } from './claimBid';\nimport { Vault } from '@metaplex-foundation/mpl-token-vault';\nimport { redeemFullRightsTransferBid } from './redeemFullRightsTransferBid';\nimport { redeemPrintingV2Bid } from './redeemPrintingV2Bid';\nimport {\n  isEligibleForParticipationPrize,\n  redeemParticipationBidV3,\n} from './redeemParticipationBidV3';\nimport { cancelBid } from './cancelBid';\n\ninterface IInstantSaleParams {\n  connection: Connection;\n  wallet: Wallet;\n  auction: PublicKey;\n  store: PublicKey;\n}\n\ninterface IInstantSaleResponse {\n  txIds: TransactionSignature[];\n}\n\nexport const instantSale = async ({\n  connection,\n  wallet,\n  store,\n  auction,\n}: IInstantSaleParams): Promise<IInstantSaleResponse> => {\n  const txIds = [];\n  // get data for transactions\n  const auctionManagerPDA = await AuctionManager.getPDA(auction);\n  const manager = await AuctionManager.load(connection, auctionManagerPDA);\n  const vault = await Vault.load(connection, manager.data.vault);\n  const auctionExtendedPDA = await AuctionExtended.getPDA(vault.pubkey);\n  const {\n    data: { instantSalePrice },\n  } = await AuctionExtended.load(connection, auctionExtendedPDA);\n  const [safetyDepositBox] = await vault.getSafetyDepositBoxes(connection);\n  const safetyDepositConfigPDA = await SafetyDepositConfig.getPDA(\n    auctionManagerPDA,\n    safetyDepositBox.pubkey,\n  );\n  const {\n    data: { winningConfigType, participationConfig },\n  } = await SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n  ////\n\n  const { txId: placeBidTxId, bidderPotToken } = await placeBid({\n    connection,\n    wallet,\n    amount: instantSalePrice,\n    auction,\n  });\n  txIds.push(placeBidTxId);\n\n  // wait for all accounts to be created\n  await connection.confirmTransaction(placeBidTxId, 'finalized');\n\n  const {\n    data: { bidState },\n  } = await Auction.load(connection, auction);\n  const winIndex = bidState.getWinnerIndex(wallet.publicKey.toBase58());\n  const hasWinner = winIndex !== null;\n\n  // NOTE: it's divided into several transactions since transaction size is restricted\n  if (hasWinner) {\n    switch (winningConfigType) {\n      case WinningConfigType.FullRightsTransfer: {\n        const { txId } = await redeemFullRightsTransferBid({ connection, wallet, store, auction });\n        txIds.push(txId);\n        break;\n      }\n      case WinningConfigType.PrintingV2: {\n        const { txId } = await redeemPrintingV2Bid({ connection, wallet, store, auction });\n        txIds.push(txId);\n        break;\n      }\n      default:\n        throw new Error(`${winningConfigType} winning type isn't supported yet`);\n    }\n\n    const { txId: claimBidTxId } = await claimBid({\n      connection,\n      wallet,\n      store,\n      auction,\n      bidderPotToken,\n    });\n    txIds.push(claimBidTxId);\n  } else {\n    // if user didn't win, user must have a bid we can refund before we check for open editions\n    const { txId } = await cancelBid({ connection, wallet, auction, bidderPotToken });\n    txIds.push(txId);\n  }\n\n  const hasWonParticipationPrize = isEligibleForParticipationPrize(winIndex, participationConfig);\n  if (hasWonParticipationPrize) {\n    const { txIds } = await redeemParticipationBidV3({ connection, wallet, store, auction });\n    txIds.push(...txIds);\n  }\n\n  return { txIds: txIds };\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { Transaction } from '@metaplex-foundation/mpl-core';\nimport { Token, TOKEN_PROGRAM_ID, u64 } from '@solana/spl-token';\n\ninterface IBurnTokenParams {\n  connection: Connection;\n  wallet: Wallet;\n  token: PublicKey;\n  mint: PublicKey;\n  amount: number | u64;\n  owner?: PublicKey;\n  // close token account after\n  close?: boolean;\n}\n\ninterface IBurnTokenResponse {\n  txId: string;\n}\n\nexport const burnToken = async ({\n  connection,\n  wallet,\n  token,\n  mint,\n  amount,\n  owner,\n  close = true,\n}: IBurnTokenParams): Promise<IBurnTokenResponse> => {\n  const tx = new Transaction({ feePayer: wallet.publicKey }).add(\n    Token.createBurnInstruction(\n      TOKEN_PROGRAM_ID,\n      mint,\n      token,\n      owner ?? wallet.publicKey,\n      [],\n      amount,\n    ),\n  );\n\n  if (close) {\n    tx.add(\n      Token.createCloseAccountInstruction(\n        TOKEN_PROGRAM_ID,\n        token,\n        wallet.publicKey,\n        owner ?? wallet.publicKey,\n        [],\n      ),\n    );\n  }\n\n  const txId = await sendTransaction({ connection, wallet, txs: [tx] });\n\n  return { txId };\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID, u64 } from '@solana/spl-token';\nimport { Wallet } from '../wallet';\nimport { Connection } from '../Connection';\nimport { sendTransaction } from './transactions';\nimport { Account, Transaction } from '@metaplex-foundation/mpl-core';\nimport { CreateAssociatedTokenAccount } from '../programs/shared/transactions/CreateAssociatedTokenAccount';\n\ninterface ISendTokenParams {\n  connection: Connection;\n  wallet: Wallet;\n  // token account address\n  source: PublicKey;\n  // destination wallet address\n  destination: PublicKey;\n  mint: PublicKey;\n  amount: number | u64;\n}\n\ninterface ISendTokenResponse {\n  txId: string;\n}\n\nexport const sendToken = async ({\n  connection,\n  wallet,\n  source,\n  destination,\n  mint,\n  amount,\n}: ISendTokenParams): Promise<ISendTokenResponse> => {\n  const txs = [];\n  const destAta = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint,\n    destination,\n  );\n  const transactionCtorFields = {\n    feePayer: wallet.publicKey,\n  };\n\n  try {\n    // check if the account exists\n    await Account.load(connection, destAta);\n  } catch {\n    txs.push(\n      new CreateAssociatedTokenAccount(transactionCtorFields, {\n        associatedTokenAddress: destAta,\n        splTokenMintAddress: mint,\n        walletAddress: destination,\n      }),\n    );\n  }\n\n  txs.push(\n    new Transaction(transactionCtorFields).add(\n      Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        source,\n        destAta,\n        wallet.publicKey,\n        [],\n        amount,\n      ),\n    ),\n  );\n\n  const txId = await sendTransaction({ connection, wallet, txs });\n\n  return { txId };\n};\n"]},"metadata":{},"sourceType":"module"}